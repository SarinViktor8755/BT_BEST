# compiler: R8
# compiler_version: 3.2.74
# min_api: 14
# common_typos_disable
# {"id":"com.android.tools.r8.mapping","version":"2.0"}
# pg_map_id: 9fb63a3
# pg_map_hash: SHA-256 9fb63a3c59de3bb0550a4135af477931f155ba288d2e2c3eb4957f7c7cca1dc4
com.badlogic.gdx.AbstractGraphics -> a.a:
com.badlogic.gdx.AbstractInput -> a.b:
    com.badlogic.gdx.utils.IntSet keysToCatch -> c
    boolean[] pressedKeys -> a
    boolean keyJustPressed -> e
    boolean[] justPressedKeys -> b
    int pressedKeyCount -> d
    boolean isKeyPressed(int) -> f
    boolean isCatchKey(int) -> k
    void setCatchKey(int,boolean) -> l
com.badlogic.gdx.Application -> a.c:
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void debug(java.lang.String,java.lang.String) -> g
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> h
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> i
    void error(java.lang.String,java.lang.String) -> j
    void log(java.lang.String,java.lang.String) -> k
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> l
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> m
    com.badlogic.gdx.Graphics getGraphics() -> n
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> o
    void postRunnable(java.lang.Runnable) -> p
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> q
    com.badlogic.gdx.utils.Clipboard getClipboard() -> r
com.badlogic.gdx.Application$ApplicationType -> a.c$a:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> c
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> g
    com.badlogic.gdx.Application$ApplicationType WebGL -> e
    com.badlogic.gdx.Application$ApplicationType Applet -> d
    com.badlogic.gdx.Application$ApplicationType iOS -> f
com.badlogic.gdx.ApplicationListener -> a.d:
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void create() -> e
    void render() -> f
com.badlogic.gdx.ApplicationLogger -> a.e:
    void debug(java.lang.String,java.lang.String) -> g
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> h
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> i
    void error(java.lang.String,java.lang.String) -> j
    void log(java.lang.String,java.lang.String) -> k
com.badlogic.gdx.Audio -> a.f:
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> A
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> k
    com.badlogic.gdx.audio.AudioDevice newAudioDevice(int,boolean) -> o
    com.badlogic.gdx.audio.AudioRecorder newAudioRecorder(int,boolean) -> p
com.badlogic.gdx.Files -> a.g:
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
com.badlogic.gdx.Files$FileType -> a.g$a:
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType Classpath -> a
com.badlogic.gdx.Game -> a.h:
    com.badlogic.gdx.Screen screen -> a
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void render() -> f
    void setScreen(com.badlogic.gdx.Screen) -> g
com.badlogic.gdx.Gdx -> a.i:
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.graphics.GL30 gl30 -> i
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
com.badlogic.gdx.Graphics -> a.j:
    int getWidth() -> b
    int getHeight() -> c
    int getBackBufferWidth() -> d
    boolean supportsExtension(java.lang.String) -> e
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> f
    void requestRendering() -> g
    float getDeltaTime() -> h
    boolean isGL30Available() -> i
    int getBackBufferHeight() -> j
com.badlogic.gdx.Graphics$BufferFormat -> a.j$a:
    int stencil -> f
    int samples -> g
    int a -> d
    int depth -> e
    boolean coverageSampling -> h
    int g -> b
    int b -> c
    int r -> a
com.badlogic.gdx.Graphics$DisplayMode -> a.j$b:
    int bitsPerPixel -> d
    int height -> b
    int refreshRate -> c
    int width -> a
com.badlogic.gdx.Input -> a.k:
    void vibrate(int) -> d
    boolean isKeyPressed(int) -> f
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> g
    void setOnscreenKeyboardVisible(boolean) -> h
    int getX() -> i
    int getY() -> j
com.badlogic.gdx.Input$OnscreenKeyboardType -> a.k$a:
    com.badlogic.gdx.Input$OnscreenKeyboardType Default -> a
    com.badlogic.gdx.Input$OnscreenKeyboardType URI -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType PhonePad -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType NumberPad -> b
    com.badlogic.gdx.Input$OnscreenKeyboardType[] $VALUES -> g
    com.badlogic.gdx.Input$OnscreenKeyboardType Password -> e
    com.badlogic.gdx.Input$OnscreenKeyboardType Email -> d
com.badlogic.gdx.Input$Orientation -> a.k$b:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation Portrait -> b
com.badlogic.gdx.InputAdapter -> a.l:
com.badlogic.gdx.InputProcessor -> a.m:
    boolean mouseMoved(int,int) -> A
    boolean touchUp(int,int,int,int) -> E
    boolean scrolled(float,float) -> G
    boolean touchDragged(int,int,int) -> Q
    boolean keyUp(int) -> W
    boolean keyTyped(char) -> k
    boolean keyDown(int) -> o
    boolean touchDown(int,int,int,int) -> p
com.badlogic.gdx.LifecycleListener -> a.n:
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.Net -> a.o:
com.badlogic.gdx.Preferences -> a.p:
    java.lang.String getString(java.lang.String) -> a
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> b
    java.lang.String getString(java.lang.String,java.lang.String) -> c
    boolean contains(java.lang.String) -> d
com.badlogic.gdx.Screen -> a.q:
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void show() -> e
    void render(float) -> f
    void hide() -> g
com.badlogic.gdx.assets.AssetDescriptor -> b.a:
    com.badlogic.gdx.files.FileHandle file -> d
    com.badlogic.gdx.assets.AssetLoaderParameters params -> c
    java.lang.String fileName -> a
    java.lang.Class type -> b
com.badlogic.gdx.assets.AssetErrorListener -> b.b:
    void error(com.badlogic.gdx.assets.AssetDescriptor,java.lang.Throwable) -> a
com.badlogic.gdx.assets.AssetLoaderParameters -> b.c:
    com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback loadedCallback -> a
com.badlogic.gdx.assets.AssetLoaderParameters$LoadedCallback -> b.c$a:
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.assets.AssetLoadingTask -> b.d:
    com.badlogic.gdx.utils.async.AsyncResult depsFuture -> i
    java.lang.Object asset -> k
    com.badlogic.gdx.utils.async.AsyncResult loadFuture -> j
    com.badlogic.gdx.assets.AssetManager manager -> a
    long startTime -> e
    com.badlogic.gdx.assets.AssetDescriptor assetDesc -> b
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> d
    boolean cancel -> l
    com.badlogic.gdx.assets.loaders.AssetLoader loader -> c
    boolean asyncDone -> f
    boolean dependenciesLoaded -> g
    com.badlogic.gdx.utils.Array dependencies -> h
    java.lang.Void call() -> a
    void handleAsyncLoader() -> b
    void handleSyncLoader() -> c
    void removeDuplicates(com.badlogic.gdx.utils.Array) -> d
    com.badlogic.gdx.files.FileHandle resolve(com.badlogic.gdx.assets.loaders.AssetLoader,com.badlogic.gdx.assets.AssetDescriptor) -> e
    void unload() -> f
    boolean update() -> g
com.badlogic.gdx.assets.AssetManager -> b.e:
    int peakTasks -> l
    int loaded -> j
    int toLoad -> k
    com.badlogic.gdx.utils.Logger log -> n
    com.badlogic.gdx.assets.AssetErrorListener listener -> i
    com.badlogic.gdx.utils.ObjectMap assets -> a
    com.badlogic.gdx.utils.async.AsyncExecutor executor -> g
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> m
    com.badlogic.gdx.utils.ObjectSet injected -> d
    com.badlogic.gdx.utils.ObjectMap loaders -> e
    com.badlogic.gdx.utils.Array tasks -> h
    com.badlogic.gdx.utils.ObjectMap assetDependencies -> c
    com.badlogic.gdx.utils.ObjectMap assetTypes -> b
    com.badlogic.gdx.utils.Array loadQueue -> f
    void finishLoading() -> A
    java.lang.Object get(java.lang.String) -> E
    java.lang.Object get(java.lang.String,java.lang.Class) -> G
    java.lang.Object get(java.lang.String,java.lang.Class,boolean) -> Q
    java.lang.Object get(java.lang.String,boolean) -> W
    java.lang.String getAssetFileName(java.lang.Object) -> X
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String) -> Y
    com.badlogic.gdx.assets.loaders.AssetLoader getLoader(java.lang.Class,java.lang.String) -> Z
    void dispose() -> a
    com.badlogic.gdx.utils.Logger getLogger() -> a0
    int getReferenceCount(java.lang.String) -> b0
    void handleTaskError(java.lang.Throwable) -> c0
    void incrementRefCountedDependencies(java.lang.String) -> d0
    void injectDependencies(java.lang.String,com.badlogic.gdx.utils.Array) -> e0
    void injectDependency(java.lang.String,com.badlogic.gdx.assets.AssetDescriptor) -> f0
    boolean isLoaded(java.lang.String) -> g0
    boolean isLoaded(java.lang.String,java.lang.Class) -> h0
    void load(java.lang.String,java.lang.Class) -> i0
    void load(java.lang.String,java.lang.Class,com.badlogic.gdx.assets.AssetLoaderParameters) -> j0
    void addAsset(java.lang.String,java.lang.Class,java.lang.Object) -> k
    void nextTask() -> k0
    void setLoader(java.lang.Class,com.badlogic.gdx.assets.loaders.AssetLoader) -> l0
    void setLoader(java.lang.Class,java.lang.String,com.badlogic.gdx.assets.loaders.AssetLoader) -> m0
    void setReferenceCount(java.lang.String,int) -> n0
    void addTask(com.badlogic.gdx.assets.AssetDescriptor) -> o
    void taskFailed(com.badlogic.gdx.assets.AssetDescriptor,java.lang.RuntimeException) -> o0
    void clear() -> p
    void unload(java.lang.String) -> p0
    boolean update() -> q0
    boolean updateTask() -> r0
com.badlogic.gdx.assets.AssetManager$RefCountedContainer -> b.e$a:
    java.lang.Object object -> a
    int refCount -> b
com.badlogic.gdx.assets.loaders.AssetLoader -> c.a:
    com.badlogic.gdx.assets.loaders.FileHandleResolver resolver -> a
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> b
com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader -> c.b:
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    void unloadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> e
com.badlogic.gdx.assets.loaders.BitmapFontLoader -> c.c:
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> g
    com.badlogic.gdx.graphics.g2d.BitmapFont loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter) -> h
com.badlogic.gdx.assets.loaders.BitmapFontLoader$BitmapFontParameter -> c.c$a:
    java.lang.String atlasName -> g
    boolean flip -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData bitmapFontData -> f
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> d
com.badlogic.gdx.assets.loaders.CubemapLoader -> c.d:
    com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapLoaderInfo info -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> g
    com.badlogic.gdx.graphics.Cubemap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter) -> h
com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapLoaderInfo -> c.d$a:
    com.badlogic.gdx.graphics.CubemapData data -> b
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.Cubemap cubemap -> c
com.badlogic.gdx.assets.loaders.CubemapLoader$CubemapParameter -> c.d$b:
    com.badlogic.gdx.graphics.CubemapData cubemapData -> d
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> e
    com.badlogic.gdx.graphics.Cubemap cubemap -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> h
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> g
com.badlogic.gdx.assets.loaders.FileHandleResolver -> c.e:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.assets.loaders.I18NBundleLoader -> c.f:
    com.badlogic.gdx.utils.I18NBundle bundle -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> g
    com.badlogic.gdx.utils.I18NBundle loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter) -> h
com.badlogic.gdx.assets.loaders.I18NBundleLoader$I18NBundleParameter -> c.f$a:
    java.util.Locale locale -> b
    java.lang.String encoding -> c
com.badlogic.gdx.assets.loaders.ModelLoader -> c.g:
    com.badlogic.gdx.utils.Array items -> b
    com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters defaultParameters -> c
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> h
    com.badlogic.gdx.graphics.g3d.Model loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> i
com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters -> c.g$a:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter textureParameter -> b
com.badlogic.gdx.assets.loaders.MusicLoader -> c.h:
    com.badlogic.gdx.audio.Music music -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> g
    com.badlogic.gdx.audio.Music loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter) -> h
com.badlogic.gdx.assets.loaders.MusicLoader$MusicParameter -> c.h$a:
com.badlogic.gdx.assets.loaders.ParticleEffectLoader -> c.i:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> d
    com.badlogic.gdx.graphics.g2d.ParticleEffect load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter) -> e
com.badlogic.gdx.assets.loaders.ParticleEffectLoader$ParticleEffectParameter -> c.i$a:
    com.badlogic.gdx.files.FileHandle imagesDir -> d
    java.lang.String atlasPrefix -> c
    java.lang.String atlasFile -> b
com.badlogic.gdx.assets.loaders.PixmapLoader -> c.j:
    com.badlogic.gdx.graphics.Pixmap pixmap -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> g
    com.badlogic.gdx.graphics.Pixmap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter) -> h
com.badlogic.gdx.assets.loaders.PixmapLoader$PixmapParameter -> c.j$a:
com.badlogic.gdx.assets.loaders.ShaderProgramLoader -> c.k:
    java.lang.String fragmentFileSuffix -> c
    java.lang.String vertexFileSuffix -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> g
    com.badlogic.gdx.graphics.glutils.ShaderProgram loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter) -> h
com.badlogic.gdx.assets.loaders.ShaderProgramLoader$ShaderProgramParameter -> c.k$a:
    java.lang.String prependFragmentCode -> f
    java.lang.String fragmentFile -> c
    java.lang.String vertexFile -> b
    java.lang.String prependVertexCode -> e
    boolean logOnCompileFailure -> d
com.badlogic.gdx.assets.loaders.SkinLoader -> c.l:
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> g
    com.badlogic.gdx.scenes.scene2d.ui.Skin loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter) -> h
    com.badlogic.gdx.scenes.scene2d.ui.Skin newSkin(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> i
com.badlogic.gdx.assets.loaders.SkinLoader$SkinParameter -> c.l$a:
    java.lang.String textureAtlasPath -> b
    com.badlogic.gdx.utils.ObjectMap resources -> c
com.badlogic.gdx.assets.loaders.SoundLoader -> c.m:
    com.badlogic.gdx.audio.Sound sound -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> g
    com.badlogic.gdx.audio.Sound loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter) -> h
com.badlogic.gdx.assets.loaders.SoundLoader$SoundParameter -> c.m$a:
com.badlogic.gdx.assets.loaders.SynchronousAssetLoader -> c.n:
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
com.badlogic.gdx.assets.loaders.TextureAtlasLoader -> c.o:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData data -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> d
    com.badlogic.gdx.graphics.g2d.TextureAtlas load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter) -> e
com.badlogic.gdx.assets.loaders.TextureAtlasLoader$TextureAtlasParameter -> c.o$a:
    boolean flip -> b
com.badlogic.gdx.assets.loaders.TextureLoader -> c.p:
    com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo info -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> g
    com.badlogic.gdx.graphics.Texture loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> h
com.badlogic.gdx.assets.loaders.TextureLoader$TextureLoaderInfo -> c.p$a:
    com.badlogic.gdx.graphics.TextureData data -> b
    java.lang.String filename -> a
    com.badlogic.gdx.graphics.Texture texture -> c
com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter -> c.p$b:
    com.badlogic.gdx.graphics.TextureData textureData -> e
    com.badlogic.gdx.graphics.Pixmap$Format format -> b
    com.badlogic.gdx.graphics.Texture texture -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapV -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> f
    boolean genMipMaps -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap wrapU -> h
com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver -> d.a:
    com.badlogic.gdx.files.FileHandle resolve(java.lang.String) -> a
com.badlogic.gdx.audio.AudioDevice -> e.a:
    void writeSamples(short[],int,int) -> R
    void dispose() -> a
com.badlogic.gdx.audio.AudioRecorder -> e.b:
    void dispose() -> a
    void read(short[],int,int) -> z
com.badlogic.gdx.audio.Music -> e.c:
com.badlogic.gdx.audio.Music$OnCompletionListener -> e.c$a:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.audio.Sound -> e.d:
    void setVolume(long,float) -> C
    void pause(long) -> K
    long play() -> M
    long loop(float) -> P
    void setLooping(long,boolean) -> T
    void setPitch(long,float) -> r
    void stop() -> s
    void resume(long) -> t
com.badlogic.gdx.backends.android.AndroidApplication -> f.a:
    int logLevel -> n
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    boolean useImmersiveMode -> p
    boolean firstResume -> i
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.utils.SnapshotArray lifecycleListeners -> l
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    boolean isWaitingForAudio -> r
    com.badlogic.gdx.utils.Array androidEventListeners -> m
    com.badlogic.gdx.ApplicationLogger applicationLogger -> o
    com.badlogic.gdx.utils.Array executedRunnables -> k
    com.badlogic.gdx.utils.Array runnables -> j
    com.badlogic.gdx.ApplicationListener listener -> g
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> f
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    android.os.Handler handler -> h
    int wasFocusChanged -> q
    com.badlogic.gdx.Audio getAudio() -> A
    com.badlogic.gdx.Files getFiles() -> B
    com.badlogic.gdx.Net getNet() -> C
    int getVersion() -> D
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> E
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> F
    void setApplicationLogger(com.badlogic.gdx.ApplicationLogger) -> G
    com.badlogic.gdx.utils.Array getRunnables() -> a
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> b
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> c
    void useImmersiveMode(boolean) -> d
    android.content.Context getContext() -> e
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void debug(java.lang.String,java.lang.String) -> g
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> h
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> i
    void error(java.lang.String,java.lang.String) -> j
    void log(java.lang.String,java.lang.String) -> k
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> l
    com.badlogic.gdx.Preferences getPreferences(java.lang.String) -> m
    com.badlogic.gdx.Graphics getGraphics() -> n
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> o
    void postRunnable(java.lang.Runnable) -> p
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> q
    com.badlogic.gdx.utils.Clipboard getClipboard() -> r
    android.view.Window getApplicationWindow() -> s
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> t
    com.badlogic.gdx.backends.android.AndroidAudio createAudio(android.content.Context,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> u
    com.badlogic.gdx.backends.android.AndroidFiles createFiles() -> v
    com.badlogic.gdx.backends.android.AndroidInput createInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> w
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> x
    void createWakeLock(boolean) -> y
    com.badlogic.gdx.ApplicationLogger getApplicationLogger() -> z
com.badlogic.gdx.backends.android.AndroidApplication$1 -> f.a$a:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.backends.android.AndroidApplicationBase -> f.b:
    com.badlogic.gdx.utils.Array getRunnables() -> a
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> b
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> c
    void useImmersiveMode(boolean) -> d
    android.content.Context getContext() -> e
    android.view.Window getApplicationWindow() -> s
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> t
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> f.c:
    boolean useWakelock -> n
    int sensorDelay -> l
    boolean disableAudio -> o
    int touchSleepTime -> m
    boolean useGyroscope -> i
    boolean useCompass -> j
    boolean useRotationVectorSensor -> k
    int stencil -> f
    int numSamples -> g
    int a -> d
    int depth -> e
    int g -> b
    int b -> c
    boolean getTouchEventsForLiveWallpaper -> r
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> q
    boolean useImmersiveMode -> s
    int r -> a
    boolean useGL30 -> t
    boolean useAccelerometer -> h
    int maxNetThreads -> u
    int maxSimultaneousSounds -> p
com.badlogic.gdx.backends.android.AndroidApplicationLogger -> f.d:
    void debug(java.lang.String,java.lang.String) -> g
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> h
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> i
    void error(java.lang.String,java.lang.String) -> j
    void log(java.lang.String,java.lang.String) -> k
com.badlogic.gdx.backends.android.AndroidAudio -> f.e:
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> F
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.backends.android.AndroidAudioDevice -> f.f:
    android.media.AudioTrack track -> a
    short[] buffer -> b
    int latency -> d
    boolean isMono -> c
    void writeSamples(short[],int,int) -> R
    void dispose() -> a
com.badlogic.gdx.backends.android.AndroidAudioRecorder -> f.g:
    android.media.AudioRecord recorder -> a
    void dispose() -> a
    void read(short[],int,int) -> z
com.badlogic.gdx.backends.android.AndroidClipboard -> f.h:
    android.content.ClipboardManager clipboard -> a
    void setContents(java.lang.String) -> a
    java.lang.String getContents() -> b
com.badlogic.gdx.backends.android.AndroidEventListener -> f.i:
    void onActivityResult(int,int,android.content.Intent) -> a
com.badlogic.gdx.backends.android.AndroidFileHandle -> f.j:
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> c
    java.io.File file() -> e
    long length() -> f
    com.badlogic.gdx.files.FileHandle parent() -> i
    java.io.InputStream read() -> m
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> s
    android.content.res.AssetFileDescriptor getAssetFileDescriptor() -> u
com.badlogic.gdx.backends.android.AndroidFiles -> f.k:
com.badlogic.gdx.backends.android.AndroidGL20 -> f.l:
    int[] ints2 -> b
    int[] ints3 -> c
    int[] ints -> a
    byte[] buffer -> d
    void glDrawArrays(int,int,int) -> B
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> C
    void glViewport(int,int,int,int) -> D
    void glTexParameterf(int,int,float) -> E
    void glUseProgram(int) -> F
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> G
    void glDeleteRenderbuffer(int) -> H
    void glBufferSubData(int,int,int,java.nio.Buffer) -> I
    int glGenTexture() -> K
    int glCreateProgram() -> L
    void glDrawElements(int,int,int,int) -> M
    int glGenFramebuffer() -> N
    java.lang.String glGetProgramInfoLog(int) -> O
    void glEnableVertexAttribArray(int) -> P
    java.lang.String glGetString(int) -> Q
    void glClear(int) -> R
    void glUniform1i(int,int) -> S
    void glBindBuffer(int,int) -> T
    void glBufferData(int,int,java.nio.Buffer,int) -> V
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> W
    int glGetUniformLocation(int,java.lang.String) -> X
    void glDeleteFramebuffer(int) -> Y
    void glPixelStorei(int,int) -> Z
    void glDepthMask(boolean) -> a0
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> b
    int glCreateShader(int) -> b0
    void glGetFloatv(int,java.nio.FloatBuffer) -> c
    void glShaderSource(int,java.lang.String) -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d0
    void glAttachShader(int,int) -> e
    void glBindTexture(int,int) -> e0
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> f
    void glDeleteShader(int) -> f0
    void glGenerateMipmap(int) -> g
    void glDeleteProgram(int) -> g0
    void glLinkProgram(int) -> h
    void glDeleteBuffer(int) -> h0
    java.lang.String glGetShaderInfoLog(int) -> i
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> i0
    void glDrawElements(int,int,int,java.nio.Buffer) -> j
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> k
    void glBlendFuncSeparate(int,int,int,int) -> l
    void glTexParameteri(int,int,int) -> n
    void glDisable(int) -> o
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> p
    int glGetAttribLocation(int,java.lang.String) -> q
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> r
    void glScissor(int,int,int,int) -> s
    void glDisableVertexAttribArray(int) -> t
    void glClearColor(float,float,float,float) -> u
    void glDeleteTexture(int) -> v
    void glCompileShader(int) -> w
    void glEnable(int) -> x
    int glGenBuffer() -> y
    void glBindFramebuffer(int,int) -> z
com.badlogic.gdx.backends.android.AndroidGL30 -> f.m:
    void glDrawArraysInstanced(int,int,int,int) -> A
    void glDrawElementsInstanced(int,int,int,int,int) -> J
    void glGenVertexArrays(int,java.nio.IntBuffer) -> U
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glBindVertexArray(int) -> c0
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> m
com.badlogic.gdx.backends.android.AndroidGraphics -> f.n:
    com.badlogic.gdx.graphics.GL30 gl30 -> j
    com.badlogic.gdx.graphics.GL20 gl20 -> i
    int safeInsetBottom -> f
    boolean running -> u
    int safeInsetLeft -> d
    boolean resume -> w
    float ppcY -> B
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> E
    int width -> b
    com.badlogic.gdx.graphics.glutils.GLVersion glVersion -> l
    int[] value -> G
    float ppiX -> y
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> h
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> D
    long frameId -> q
    float deltaTime -> o
    int fps -> s
    java.lang.Object synch -> H
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 view -> a
    boolean enforceContinuousRendering -> I
    java.lang.String extensions -> m
    int safeInsetRight -> g
    boolean pause -> v
    float density -> C
    int safeInsetTop -> e
    boolean destroy -> x
    float ppcX -> A
    int height -> c
    boolean created -> t
    float ppiY -> z
    javax.microedition.khronos.egl.EGLContext eglContext -> k
    boolean isContinuous -> F
    long lastFrameTime -> n
    int frames -> r
    long frameStart -> p
    void updatePpi() -> A
    void updateSafeAreaInsets() -> B
    boolean checkGL20() -> a
    int getWidth() -> b
    int getHeight() -> c
    int getBackBufferWidth() -> d
    boolean supportsExtension(java.lang.String) -> e
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> f
    void requestRendering() -> g
    float getDeltaTime() -> h
    boolean isGL30Available() -> i
    int getBackBufferHeight() -> j
    void clearManagedCaches() -> k
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> l
    void destroy() -> m
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> n
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> o
    android.view.View getView() -> p
    boolean isContinuousRendering() -> q
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> r
    void logManagedCachesStatus() -> s
    void onPauseGLSurfaceView() -> t
    void onResumeGLSurfaceView() -> u
    void pause() -> v
    void preserveEGLContextOnPause() -> w
    void resume() -> x
    void setContinuousRendering(boolean) -> y
    void setupGL(javax.microedition.khronos.opengles.GL10) -> z
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> f.n$a:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> a
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> f.n$b:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidInput -> f.o:
    void onPause() -> a
    void onResume() -> b
    void setKeyboardAvailable(boolean) -> c
    void processEvents() -> e
com.badlogic.gdx.backends.android.AndroidMouseHandler -> f.p:
    int deltaY -> b
    int deltaX -> a
    boolean onGenericMotion(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
com.badlogic.gdx.backends.android.AndroidMusic -> f.q:
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> f
    com.badlogic.gdx.backends.android.AndroidAudio audio -> a
    float volume -> e
    android.media.MediaPlayer player -> b
    boolean isPrepared -> c
    boolean wasPlaying -> d
    void dispose() -> a
    void pause() -> c
    boolean isPlaying() -> k
    void play() -> o
com.badlogic.gdx.backends.android.AndroidMusic$1 -> f.q$a:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> a
com.badlogic.gdx.backends.android.AndroidNet -> f.r:
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
com.badlogic.gdx.backends.android.AndroidPreferences -> f.s:
    android.content.SharedPreferences$Editor editor -> b
    android.content.SharedPreferences sharedPrefs -> a
    java.lang.String getString(java.lang.String) -> a
    com.badlogic.gdx.Preferences putString(java.lang.String,java.lang.String) -> b
    java.lang.String getString(java.lang.String,java.lang.String) -> c
    boolean contains(java.lang.String) -> d
    void edit() -> e
com.badlogic.gdx.backends.android.AndroidSound -> f.t:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    com.badlogic.gdx.utils.IntArray streamIds -> d
    int soundId -> c
    void setVolume(long,float) -> C
    void pause(long) -> K
    long play() -> M
    long loop(float) -> P
    void setLooping(long,boolean) -> T
    void dispose() -> a
    long play(float) -> k
    void setPitch(long,float) -> r
    void stop() -> s
    void resume(long) -> t
com.badlogic.gdx.backends.android.AndroidTouchHandler -> f.u:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
    boolean supportsMultitouch(android.content.Context) -> c
    int toGdxButton(int) -> d
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> f.v:
    void createListener(com.badlogic.gdx.backends.android.AndroidApplicationBase) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 -> f.v$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener this$0 -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase val$application -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1$1 -> f.v$a$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 this$1 -> a
com.badlogic.gdx.backends.android.DefaultAndroidAudio -> f.w:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    java.util.List musics -> c
    com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle) -> A
    android.media.MediaPlayer createMediaPlayer() -> E
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> F
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle) -> k
    com.badlogic.gdx.audio.AudioDevice newAudioDevice(int,boolean) -> o
    com.badlogic.gdx.audio.AudioRecorder newAudioRecorder(int,boolean) -> p
com.badlogic.gdx.backends.android.DefaultAndroidFiles -> f.x:
    android.content.res.AssetManager assets -> c
    java.lang.String externalFilesPath -> a
    java.lang.String localpath -> b
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
    java.lang.String initExternalFilesPath(android.content.ContextWrapper) -> f
com.badlogic.gdx.backends.android.DefaultAndroidInput -> f.y:
    float pitch -> L
    boolean justTouched -> N
    android.content.Context context -> B
    float[] magneticFieldValues -> I
    boolean[] touched -> o
    android.hardware.SensorEventListener accelerometerListener -> S
    boolean hasMultitouch -> s
    android.hardware.SensorEventListener compassListener -> U
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> P
    java.util.ArrayList keyEvents -> i
    int[] deltaY -> n
    long currentEventTimeStamp -> R
    int[] button -> p
    boolean rotationVectorAvailable -> G
    com.badlogic.gdx.Input$Orientation nativeOrientation -> Q
    com.badlogic.gdx.utils.Pool usedKeyEvents -> f
    float[] pressure -> r
    com.badlogic.gdx.backends.android.AndroidMouseHandler mouseHandler -> X
    int[] touchY -> l
    android.hardware.SensorEventListener rotationVectorListener -> V
    float azimuth -> K
    float[] rotationVectorValues -> J
    boolean[] justPressedButtons -> t
    android.os.Vibrator vibrator -> E
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> C
    boolean accelerometerAvailable -> v
    int sleepTime -> D
    boolean gyroscopeAvailable -> x
    com.badlogic.gdx.Application app -> A
    android.os.Handler handle -> z
    com.badlogic.gdx.InputProcessor processor -> O
    android.hardware.SensorEventListener gyroscopeListener -> T
    float[] gyroscopeValues -> y
    boolean requestFocus -> Y
    java.util.ArrayList touchEvents -> j
    float[] R -> Z
    float[] accelerometerValues -> w
    java.util.ArrayList keyListeners -> h
    java.util.ArrayList genericMotionListeners -> W
    android.hardware.SensorManager manager -> u
    boolean compassAvailable -> F
    int[] realId -> q
    boolean keyboardAvailable -> H
    int[] touchX -> k
    float[] orientation -> a0
    com.badlogic.gdx.utils.Pool usedTouchEvents -> g
    int[] deltaX -> m
    float roll -> M
    void onPause() -> a
    void onResume() -> b
    void setKeyboardAvailable(boolean) -> c
    void vibrate(int) -> d
    void processEvents() -> e
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> g
    void setOnscreenKeyboardVisible(boolean) -> h
    int getX() -> i
    int getY() -> j
    int getAndroidInputType(com.badlogic.gdx.Input$OnscreenKeyboardType) -> m
    int getFreePointerIndex() -> n
    int getRotation() -> o
    int lookUpPointerIndex(int) -> p
    void registerSensorListeners() -> q
    float[] resize(float[]) -> r
    int[] resize(int[]) -> s
    boolean[] resize(boolean[]) -> t
    void setOnscreenKeyboardVisible(boolean,com.badlogic.gdx.Input$OnscreenKeyboardType) -> u
    void unregisterSensorListeners() -> v
com.badlogic.gdx.backends.android.DefaultAndroidInput$1 -> f.y$a:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$2 -> f.y$b:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$4 -> f.y$c:
    boolean val$visible -> a
    com.badlogic.gdx.Input$OnscreenKeyboardType val$type -> b
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$5 -> f.y$d:
    int[] $SwitchMap$com$badlogic$gdx$Input$OnscreenKeyboardType -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent -> f.y$e:
    long timeStamp -> a
    int type -> b
    char keyChar -> d
    int keyCode -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$SensorListener -> f.y$f:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent -> f.y$g:
    int pointer -> h
    int scrollAmountY -> f
    long timeStamp -> a
    int button -> g
    int y -> d
    int scrollAmountX -> e
    int type -> b
    int x -> c
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> g.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> g.b:
    int targetGLESVersion -> d
    java.lang.String TAG -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType onscreenKeyboardType -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    boolean checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
    void init(boolean,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> g.b$a:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> g.b$b:
    int[] mValue -> g
    int[] s_configAttribs2 -> h
    int mStencilSize -> f
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> g.b$c:
    int EGL_CONTEXT_CLIENT_VERSION -> a
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> g.c:
    int[] mConfigAttribs -> h
    int[] mValue -> i
    int mStencilSize -> f
    int mNumSamples -> g
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> g.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> g.d$a:
    int height -> b
    int width -> a
com.badlogic.gdx.files.FileHandle -> h.a:
    java.io.File file -> a
    com.badlogic.gdx.Files$FileType type -> b
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    int estimateLength() -> b
    boolean exists() -> c
    java.lang.String extension() -> d
    java.io.File file() -> e
    long length() -> f
    java.lang.String name() -> g
    java.lang.String nameWithoutExtension() -> h
    com.badlogic.gdx.files.FileHandle parent() -> i
    java.lang.String path() -> j
    java.lang.String pathWithoutExtension() -> k
    java.io.BufferedInputStream read(int) -> l
    java.io.InputStream read() -> m
    byte[] readBytes() -> n
    java.lang.String readString() -> o
    java.lang.String readString(java.lang.String) -> p
    java.io.BufferedReader reader(int) -> q
    java.io.Reader reader(java.lang.String) -> r
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> s
    com.badlogic.gdx.Files$FileType type() -> t
com.badlogic.gdx.files.FileHandle$1 -> h.a$a:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> i.a:
    float viewportHeight -> k
    float viewportWidth -> j
    float far -> i
    float near -> h
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.collision.Ray ray -> n
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
    void update() -> c
com.badlogic.gdx.graphics.Color -> i.b:
    com.badlogic.gdx.graphics.Color RED -> E
    com.badlogic.gdx.graphics.Color CORAL -> G
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> f
    com.badlogic.gdx.graphics.Color PINK -> I
    com.badlogic.gdx.graphics.Color DARK_GRAY -> h
    com.badlogic.gdx.graphics.Color PURPLE -> K
    float b -> c
    float r -> a
    com.badlogic.gdx.graphics.Color ORANGE -> A
    com.badlogic.gdx.graphics.Color TAN -> C
    com.badlogic.gdx.graphics.Color CHARTREUSE -> t
    com.badlogic.gdx.graphics.Color FOREST -> v
    com.badlogic.gdx.graphics.Color YELLOW -> x
    com.badlogic.gdx.graphics.Color GOLDENROD -> z
    com.badlogic.gdx.graphics.Color MAROON -> M
    com.badlogic.gdx.graphics.Color BLUE -> l
    com.badlogic.gdx.graphics.Color ROYAL -> n
    com.badlogic.gdx.graphics.Color SKY -> p
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color WHITE -> e
    com.badlogic.gdx.graphics.Color FIREBRICK -> D
    com.badlogic.gdx.graphics.Color GRAY -> g
    float WHITE_FLOAT_BITS -> j
    com.badlogic.gdx.graphics.Color SCARLET -> F
    com.badlogic.gdx.graphics.Color BLACK -> i
    com.badlogic.gdx.graphics.Color SALMON -> H
    com.badlogic.gdx.graphics.Color CLEAR -> k
    com.badlogic.gdx.graphics.Color MAGENTA -> J
    float a -> d
    float g -> b
    com.badlogic.gdx.graphics.Color BROWN -> B
    com.badlogic.gdx.graphics.Color LIME -> u
    com.badlogic.gdx.graphics.Color OLIVE -> w
    com.badlogic.gdx.graphics.Color GOLD -> y
    com.badlogic.gdx.graphics.Color NAVY -> m
    com.badlogic.gdx.graphics.Color VIOLET -> L
    com.badlogic.gdx.graphics.Color SLATE -> o
    com.badlogic.gdx.graphics.Color CYAN -> q
    com.badlogic.gdx.graphics.Color GREEN -> s
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,float) -> a
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,int) -> b
    com.badlogic.gdx.graphics.Color clamp() -> c
    com.badlogic.gdx.graphics.Color cpy() -> d
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> e
    int rgba8888(float,float,float,float) -> f
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> g
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> h
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> i
    float toFloatBits() -> j
    float toFloatBits(float,float,float,float) -> k
    int toIntBits() -> l
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> m
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String,com.badlogic.gdx.graphics.Color) -> n
com.badlogic.gdx.graphics.Colors -> i.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> b
com.badlogic.gdx.graphics.Cubemap -> i.d:
    com.badlogic.gdx.graphics.CubemapData data -> i
    java.util.Map managedCubemaps -> k
    com.badlogic.gdx.assets.AssetManager assetManager -> j
    void dispose() -> a
    void addManagedCubemap(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Cubemap) -> d0
    void clearAllCubemaps(com.badlogic.gdx.Application) -> e0
    com.badlogic.gdx.graphics.CubemapData getCubemapData() -> f0
    java.lang.String getManagedStatus() -> g0
    void invalidateAllCubemaps(com.badlogic.gdx.Application) -> h0
    boolean isManaged() -> i0
    void load(com.badlogic.gdx.graphics.CubemapData) -> j0
    void reload() -> k0
com.badlogic.gdx.graphics.Cubemap$1 -> i.d$a:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.CubemapData -> i.e:
    void prepare() -> a
    boolean isManaged() -> d
    boolean isPrepared() -> e
    void consumeCubemapData() -> g
com.badlogic.gdx.graphics.GL20 -> i.f:
    void glDrawArrays(int,int,int) -> B
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> C
    void glViewport(int,int,int,int) -> D
    void glTexParameterf(int,int,float) -> E
    void glUseProgram(int) -> F
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> G
    void glDeleteRenderbuffer(int) -> H
    void glBufferSubData(int,int,int,java.nio.Buffer) -> I
    int glGenTexture() -> K
    int glCreateProgram() -> L
    void glDrawElements(int,int,int,int) -> M
    int glGenFramebuffer() -> N
    java.lang.String glGetProgramInfoLog(int) -> O
    void glEnableVertexAttribArray(int) -> P
    java.lang.String glGetString(int) -> Q
    void glClear(int) -> R
    void glUniform1i(int,int) -> S
    void glBindBuffer(int,int) -> T
    void glBufferData(int,int,java.nio.Buffer,int) -> V
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> W
    int glGetUniformLocation(int,java.lang.String) -> X
    void glDeleteFramebuffer(int) -> Y
    void glPixelStorei(int,int) -> Z
    void glDepthMask(boolean) -> a0
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> b
    int glCreateShader(int) -> b0
    void glGetFloatv(int,java.nio.FloatBuffer) -> c
    void glShaderSource(int,java.lang.String) -> d
    void glGetIntegerv(int,java.nio.IntBuffer) -> d0
    void glAttachShader(int,int) -> e
    void glBindTexture(int,int) -> e0
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> f
    void glDeleteShader(int) -> f0
    void glGenerateMipmap(int) -> g
    void glDeleteProgram(int) -> g0
    void glLinkProgram(int) -> h
    void glDeleteBuffer(int) -> h0
    java.lang.String glGetShaderInfoLog(int) -> i
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> i0
    void glDrawElements(int,int,int,java.nio.Buffer) -> j
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> k
    void glBlendFuncSeparate(int,int,int,int) -> l
    void glTexParameteri(int,int,int) -> n
    void glDisable(int) -> o
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> p
    int glGetAttribLocation(int,java.lang.String) -> q
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> r
    void glScissor(int,int,int,int) -> s
    void glDisableVertexAttribArray(int) -> t
    void glClearColor(float,float,float,float) -> u
    void glDeleteTexture(int) -> v
    void glCompileShader(int) -> w
    void glEnable(int) -> x
    int glGenBuffer() -> y
    void glBindFramebuffer(int,int) -> z
com.badlogic.gdx.graphics.GL30 -> i.g:
    void glDrawArraysInstanced(int,int,int,int) -> A
    void glDrawElementsInstanced(int,int,int,int,int) -> J
    void glGenVertexArrays(int,java.nio.IntBuffer) -> U
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> a
    void glBindVertexArray(int) -> c0
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> m
com.badlogic.gdx.graphics.GLTexture -> i.h:
    float maxAnisotropicFilterLevel -> h
    float anisotropicFilterLevel -> g
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    int glTarget -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> A
    int getTextureObjectHandle() -> E
    com.badlogic.gdx.graphics.Texture$TextureWrap getUWrap() -> G
    com.badlogic.gdx.graphics.Texture$TextureWrap getVWrap() -> Q
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> W
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> X
    float unsafeSetAnisotropicFilter(float,boolean) -> Y
    void unsafeSetFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> Z
    void dispose() -> a
    void unsafeSetWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap,boolean) -> a0
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> b0
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> c0
    void delete() -> k
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> o
    float getMaxAnisotropicFilterLevel() -> p
    void bind() -> x
com.badlogic.gdx.graphics.Mesh -> i.i:
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> a
    com.badlogic.gdx.graphics.glutils.IndexData indices -> b
    com.badlogic.gdx.graphics.glutils.InstanceData instances -> e
    boolean isInstanced -> f
    boolean autoBind -> c
    boolean isVertexArray -> d
    com.badlogic.gdx.math.Vector3 tmpV -> g
    java.util.Map meshes -> h
    void clearAllMeshes(com.badlogic.gdx.Application) -> A
    int getNumIndices() -> D
    com.badlogic.gdx.math.collision.BoundingBox extendBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int) -> E
    com.badlogic.gdx.math.collision.BoundingBox extendBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int,com.badlogic.gdx.math.Matrix4) -> G
    java.nio.ShortBuffer getIndicesBuffer() -> Q
    java.lang.String getManagedStatus() -> W
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> X
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> Y
    java.nio.FloatBuffer getVerticesBuffer() -> Z
    void dispose() -> a
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> a0
    com.badlogic.gdx.graphics.glutils.VertexData makeVertexBuffer(boolean,int,com.badlogic.gdx.graphics.VertexAttributes) -> b0
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> c0
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> d0
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> e0
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> f0
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> g0
    int getNumVertices() -> h
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> h0
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> k
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> o
    com.badlogic.gdx.math.collision.BoundingBox calculateBoundingBox(com.badlogic.gdx.math.collision.BoundingBox,int,int) -> p
com.badlogic.gdx.graphics.Mesh$1 -> i.i$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$Mesh$VertexDataType -> a
com.badlogic.gdx.graphics.Mesh$VertexDataType -> i.i$b:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectWithVAO -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> e
com.badlogic.gdx.graphics.OrthographicCamera -> i.j:
    com.badlogic.gdx.math.Vector3 tmp -> p
    float zoom -> o
    void update() -> c
    void update(boolean) -> d
com.badlogic.gdx.graphics.Pixmap -> i.k:
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> c
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> a
    boolean disposed -> e
    com.badlogic.gdx.graphics.Pixmap$Filter filter -> b
    int color -> d
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> A
    void setColor(float,float,float,float) -> B
    int getGLFormat() -> E
    int getGLInternalFormat() -> G
    int getGLType() -> Q
    int getHeight() -> W
    java.nio.ByteBuffer getPixels() -> X
    int getWidth() -> Y
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> Z
    void dispose() -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> k
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> o
    void fill() -> p
com.badlogic.gdx.graphics.Pixmap$Blending -> i.k$a:
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
com.badlogic.gdx.graphics.Pixmap$Filter -> i.k$b:
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> a
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> b
com.badlogic.gdx.graphics.Pixmap$Format -> i.k$c:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.PixmapIO -> i.l:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> i.l$a:
    byte[] readBuffer -> b
    byte[] writeBuffer -> a
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> i.m:
    java.util.Map managedTextures -> k
    com.badlogic.gdx.assets.AssetManager assetManager -> j
    com.badlogic.gdx.graphics.TextureData data -> i
    void dispose() -> a
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> d0
    void clearAllTextures(com.badlogic.gdx.Application) -> e0
    int getHeight() -> f0
    java.lang.String getManagedStatus() -> g0
    com.badlogic.gdx.graphics.TextureData getTextureData() -> h0
    int getWidth() -> i0
    void invalidateAllTextures(com.badlogic.gdx.Application) -> j0
    boolean isManaged() -> k0
    void load(com.badlogic.gdx.graphics.TextureData) -> l0
    void reload() -> m0
com.badlogic.gdx.graphics.Texture$1 -> i.m$a:
    int val$refCount -> a
    void finishedLoading(com.badlogic.gdx.assets.AssetManager,java.lang.String,java.lang.Class) -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> i.m$b:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    int glEnum -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> c
    int getGLEnum() -> a
    boolean isMipMap() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> i.m$c:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    int glEnum -> a
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureArray -> i.n:
    com.badlogic.gdx.graphics.TextureArrayData data -> i
    java.util.Map managedTextureArrays -> j
    void clearAllTextureArrays(com.badlogic.gdx.Application) -> d0
    void invalidateAllTextureArrays(com.badlogic.gdx.Application) -> e0
    boolean isManaged() -> f0
    void load(com.badlogic.gdx.graphics.TextureArrayData) -> g0
    void reload() -> h0
com.badlogic.gdx.graphics.TextureArrayData -> i.o:
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    int getDepth() -> f
    int getGLType() -> g
    int getInternalFormat() -> h
    void consumeTextureArrayData() -> i
com.badlogic.gdx.graphics.TextureData -> i.p:
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    boolean disposePixmap() -> h
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> i
    boolean useMipMaps() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.TextureData$Factory -> i.p$a:
    com.badlogic.gdx.graphics.TextureData loadFromFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
com.badlogic.gdx.graphics.TextureData$TextureDataType -> i.p$b:
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> b
com.badlogic.gdx.graphics.VertexAttribute -> i.q:
    java.lang.String alias -> f
    int usageIndex -> h
    int unit -> g
    int type -> d
    int offset -> e
    int numComponents -> b
    boolean normalized -> c
    int usage -> a
    com.badlogic.gdx.graphics.VertexAttribute Binormal() -> a
    com.badlogic.gdx.graphics.VertexAttribute BoneWeight(int) -> b
    com.badlogic.gdx.graphics.VertexAttribute ColorPacked() -> c
    com.badlogic.gdx.graphics.VertexAttribute ColorUnpacked() -> d
    com.badlogic.gdx.graphics.VertexAttribute Normal() -> e
    com.badlogic.gdx.graphics.VertexAttribute Position() -> f
    com.badlogic.gdx.graphics.VertexAttribute Tangent() -> g
    com.badlogic.gdx.graphics.VertexAttribute TexCoords(int) -> h
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> i
    int getKey() -> j
    int getSizeInBytes() -> k
com.badlogic.gdx.graphics.VertexAttributes -> i.r:
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> d
    long mask -> c
    int vertexSize -> b
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> a
    int calculateOffsets() -> a
    int compareTo(com.badlogic.gdx.graphics.VertexAttributes) -> b
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> c
    long getMask() -> d
    int size() -> e
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> i.r$a:
    java.lang.Object[] array -> a
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> c
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> b
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> i.r$b:
    java.lang.Object[] array -> a
    int index -> b
    boolean valid -> c
com.badlogic.gdx.graphics.g2d.Batch -> j.a:
    void setColor(float,float,float,float) -> B
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> H
    void setPackedColor(float) -> I
    float getPackedColor() -> J
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> S
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> U
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> V
    void end() -> e
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> j
    void setColor(com.badlogic.gdx.graphics.Color) -> l
    com.badlogic.gdx.graphics.Color getColor() -> n
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> q
    void begin() -> w
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> y
com.badlogic.gdx.graphics.g2d.BitmapFont -> j.b:
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    boolean integer -> e
    boolean ownsTexture -> f
    com.badlogic.gdx.utils.Array regions -> b
    boolean flipped -> d
    float getCapHeight() -> A
    void setColor(float,float,float,float) -> B
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData getData() -> E
    float getDescent() -> G
    com.badlogic.gdx.utils.Array getRegions() -> Q
    float getScaleX() -> W
    float getScaleY() -> X
    boolean isFlipped() -> Y
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> Z
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFontCache newFontCache() -> a0
    void setUseIntegerPositions(boolean) -> b0
    boolean usesIntegerPositions() -> c0
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float) -> k
    void setColor(com.badlogic.gdx.graphics.Color) -> l
    com.badlogic.gdx.graphics.Color getColor() -> n
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean) -> o
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> p
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> j.b$a:
    float ascent -> k
    float lineHeight -> i
    com.badlogic.gdx.files.FileHandle fontFile -> c
    float padBottom -> g
    float padTop -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph missingGlyph -> t
    char[] capChars -> y
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> s
    boolean markupEnabled -> q
    float spaceXadvance -> u
    char[] xChars -> x
    java.lang.String name -> a
    float scaleX -> o
    boolean flipped -> d
    float down -> m
    float descent -> l
    float capHeight -> j
    float padLeft -> h
    float padRight -> f
    java.lang.String[] imagePaths -> b
    float xHeight -> v
    char[] breakChars -> w
    float cursorX -> r
    float scaleY -> p
    float blankLineScale -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> b
    void getGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> c
    java.lang.String getImagePath(int) -> d
    java.lang.String[] getImagePaths() -> e
    int getWrapIndex(com.badlogic.gdx.utils.Array,int) -> f
    boolean hasGlyph(char) -> g
    boolean isBreakChar(char) -> h
    boolean isWhitespace(char) -> i
    void load(com.badlogic.gdx.files.FileHandle,boolean) -> j
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> k
    void setGlyphRegion(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.TextureRegion) -> l
    void setScale(float) -> m
    void setScale(float,float) -> n
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> j.b$b:
    boolean fixedWidth -> n
    int page -> o
    int xadvance -> l
    float v2 -> i
    float u2 -> h
    int xoffset -> j
    float v -> g
    int yoffset -> k
    float u -> f
    int width -> d
    int height -> e
    int srcX -> b
    int srcY -> c
    byte[][] kerning -> m
    int id -> a
    int getKerning(char) -> a
    void setKerning(int,int) -> b
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> j.c:
    float currentTint -> i
    float y -> g
    com.badlogic.gdx.graphics.Color color -> h
    float x -> f
    com.badlogic.gdx.utils.IntArray[] pageGlyphIndices -> l
    int glyphCount -> e
    com.badlogic.gdx.utils.Array pooledLayouts -> d
    com.badlogic.gdx.utils.Array layouts -> c
    com.badlogic.gdx.graphics.Color tempColor -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] pageVertices -> j
    boolean integer -> b
    int[] idx -> k
    int[] tempGlyphCount -> m
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float) -> b
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean) -> c
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> d
    void addText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> e
    void addToCache(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> f
    void clear() -> g
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> h
    com.badlogic.gdx.graphics.Color getColor() -> i
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> j
    void requireGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> k
    void requirePageGlyphs(int,int) -> l
    void setPageCount(int) -> m
    void setPosition(float,float) -> n
    void setText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> o
    void setUseIntegerPositions(boolean) -> p
    void tint(com.badlogic.gdx.graphics.Color) -> q
    void translate(float,float) -> r
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long[] nativeData -> f
    long basePtr -> a
    java.nio.ByteBuffer pixelPtr -> e
    int format -> d
    int width -> b
    int height -> c
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> A
    int getFormat() -> E
    java.lang.String getFormatString(int) -> G
    int getGLFormat() -> Q
    int getGLInternalFormat() -> W
    int getGLType() -> X
    int getHeight() -> Y
    java.nio.ByteBuffer getPixels() -> Z
    void dispose() -> a
    int getWidth() -> a0
    void setBlend(int) -> b0
    int toGlFormat(int) -> c0
    int toGlType(int) -> d0
    void clear(int) -> k
    void convert(int) -> o
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> p
com.badlogic.gdx.graphics.g2d.GlyphLayout -> j.d:
    com.badlogic.gdx.utils.Array runs -> a
    com.badlogic.gdx.utils.IntArray colors -> b
    float height -> e
    float width -> d
    int glyphCount -> c
    com.badlogic.gdx.utils.Pool glyphRunPool -> f
    com.badlogic.gdx.utils.IntArray colorStack -> g
    void alignRuns(float,int) -> a
    void reset() -> b
    void calculateWidths(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> c
    float getGlyphWidth(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> d
    float getLineOffset(com.badlogic.gdx.utils.Array,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> e
    int parseColorMarkup(java.lang.CharSequence,int,int) -> f
    void setLastGlyphXAdvance(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> g
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence) -> h
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.Color,float,int,boolean,java.lang.String) -> i
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,com.badlogic.gdx.graphics.Color,float,int,boolean) -> j
    void truncate(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,float,java.lang.String) -> k
    com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun wrap(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,int) -> l
com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun -> j.d$a:
    com.badlogic.gdx.utils.Array glyphs -> a
    float width -> e
    float y -> d
    float x -> c
    com.badlogic.gdx.utils.FloatArray xAdvances -> b
    void appendRun(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> a
    void reset() -> b
com.badlogic.gdx.graphics.g2d.NinePatch -> j.e:
    float rightWidth -> l
    float leftWidth -> k
    int topRight -> j
    int topLeft -> h
    int topCenter -> i
    int middleCenter -> f
    int middleRight -> g
    int bottomRight -> d
    int middleLeft -> e
    int bottomLeft -> b
    int bottomCenter -> c
    com.badlogic.gdx.graphics.Texture texture -> a
    float padBottom -> w
    com.badlogic.gdx.graphics.Color tmpDrawColor -> x
    float padTop -> v
    float padRight -> u
    float padLeft -> t
    float bottomHeight -> p
    float[] vertices -> q
    int idx -> r
    float topHeight -> o
    float middleHeight -> n
    com.badlogic.gdx.graphics.Color color -> s
    float middleWidth -> m
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> b
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> c
    float getBottomHeight() -> d
    float getLeftWidth() -> e
    float getPadBottom() -> f
    float getPadLeft() -> g
    float getPadRight() -> h
    float getPadTop() -> i
    float getRightWidth() -> j
    float getTopHeight() -> k
    float getTotalHeight() -> l
    float getTotalWidth() -> m
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> n
    void prepareVertices(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> o
    void scale(float,float) -> p
    void set(int,float,float,float,float,float) -> q
    void setPadding(float,float,float,float) -> r
com.badlogic.gdx.graphics.g2d.ParticleEffect -> j.f:
    com.badlogic.gdx.utils.Array emitters -> a
    float motionScale -> e
    float ySizeScale -> d
    float xSizeScale -> c
    boolean ownsTexture -> b
    void loadEmitterImages(com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> A
    void loadEmitters(com.badlogic.gdx.files.FileHandle) -> E
    com.badlogic.gdx.graphics.Texture loadTexture(com.badlogic.gdx.files.FileHandle) -> G
    com.badlogic.gdx.graphics.g2d.ParticleEmitter newEmitter(java.io.BufferedReader) -> Q
    void dispose() -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle) -> k
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.TextureAtlas,java.lang.String) -> o
    void loadEmitterImages(com.badlogic.gdx.files.FileHandle) -> p
com.badlogic.gdx.graphics.g2d.ParticleEmitter -> j.g:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue angleValue -> j
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue rotationValue -> h
    com.badlogic.gdx.utils.Array imagePaths -> z
    boolean cleansUpBlendFunction -> J
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue gravityValue -> l
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnHeightValue -> r
    com.badlogic.gdx.utils.Array sprites -> t
    int activeCount -> A
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue xOffsetValue -> o
    boolean continuous -> E
    int minParticleCount -> w
    boolean behind -> G
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue xScaleValue -> f
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue windValue -> k
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue velocityValue -> i
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue durationValue -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle[] particles -> v
    boolean premultipliedAlpha -> I
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue delayValue -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue transparencyValue -> m
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue tintValue -> n
    float duration -> C
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue spawnWidthValue -> q
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue yOffsetValue -> p
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode spriteMode -> u
    java.lang.String name -> y
    int maxParticleCount -> x
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue lifeValue -> d
    boolean[] active -> B
    boolean aligned -> F
    boolean additive -> H
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue yScaleValue -> g
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue spawnShapeValue -> s
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue emissionValue -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue lifeOffsetValue -> b
    boolean attached -> D
    com.badlogic.gdx.utils.Array getImagePaths() -> a
    com.badlogic.gdx.utils.Array getSprites() -> b
    void initialize() -> c
    void load(java.io.BufferedReader) -> d
    boolean readBoolean(java.io.BufferedReader,java.lang.String) -> e
    boolean readBoolean(java.lang.String) -> f
    float readFloat(java.io.BufferedReader,java.lang.String) -> g
    int readInt(java.io.BufferedReader,java.lang.String) -> h
    java.lang.String readString(java.io.BufferedReader,java.lang.String) -> i
    java.lang.String readString(java.lang.String) -> j
    void setImagePaths(com.badlogic.gdx.utils.Array) -> k
    void setMaxParticleCount(int) -> l
    void setMinParticleCount(int) -> m
    void setSprites(com.badlogic.gdx.utils.Array) -> n
com.badlogic.gdx.graphics.g2d.ParticleEmitter$GradientColorValue -> j.g$a:
    float[] temp -> e
    float[] colors -> c
    float[] timeline -> d
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$IndependentScaledNumericValue -> j.g$b:
    boolean independent -> j
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$Particle -> j.g$c:
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ParticleValue -> j.g$d:
    boolean active -> a
    boolean alwaysActive -> b
    void load(java.io.BufferedReader) -> a
    void setActive(boolean) -> b
    void setAlwaysActive(boolean) -> c
com.badlogic.gdx.graphics.g2d.ParticleEmitter$RangedNumericValue -> j.g$e:
    float lowMax -> d
    float lowMin -> c
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$ScaledNumericValue -> j.g$f:
    float highMax -> h
    boolean relative -> i
    float highMin -> g
    float[] scaling -> e
    float[] timeline -> f
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide -> j.g$g:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide[] $VALUES -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide both -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide bottom -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide top -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape -> j.g$h:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape[] $VALUES -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape ellipse -> d
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape point -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape square -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape line -> b
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShapeValue -> j.g$i:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnEllipseSide side -> e
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpawnShape shape -> c
    boolean edges -> d
    void load(java.io.BufferedReader) -> a
com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode -> j.g$j:
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode random -> b
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode animated -> c
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode single -> a
    com.badlogic.gdx.graphics.g2d.ParticleEmitter$SpriteMode[] $VALUES -> d
com.badlogic.gdx.graphics.g2d.PolygonRegion -> j.h:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> d
    float[] textureCoords -> a
    float[] vertices -> b
    short[] triangles -> c
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader -> j.i:
    com.badlogic.gdx.math.EarClippingTriangulator triangulator -> c
    com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters defaultParameters -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    java.lang.Object load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> d
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters) -> e
    com.badlogic.gdx.graphics.g2d.PolygonRegion load(com.badlogic.gdx.graphics.g2d.TextureRegion,com.badlogic.gdx.files.FileHandle) -> f
com.badlogic.gdx.graphics.g2d.PolygonRegionLoader$PolygonRegionParameters -> j.i$a:
    java.lang.String[] textureExtensions -> d
    java.lang.String texturePrefix -> b
    int readerBuffer -> c
com.badlogic.gdx.graphics.g2d.Sprite -> j.j:
    float width -> l
    float y -> k
    float x -> j
    com.badlogic.gdx.graphics.Color color -> i
    float[] vertices -> h
    float scaleY -> r
    float scaleX -> q
    float rotation -> p
    float originY -> o
    float originX -> n
    boolean dirty -> s
    float height -> m
    void setColor(float,float,float,float) -> A
    void setColor(com.badlogic.gdx.graphics.Color) -> B
    void setOrigin(float,float) -> C
    void setPackedColor(float) -> D
    void setRotation(float) -> E
    void setScale(float,float) -> F
    void setSize(float,float) -> G
    void translate(float,float) -> H
    void flip(boolean,boolean) -> a
    void setRegion(float,float,float,float) -> k
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> o
    com.badlogic.gdx.graphics.Color getColor() -> p
    float getHeight() -> q
    float getOriginX() -> r
    float getOriginY() -> s
    float[] getVertices() -> t
    float getWidth() -> u
    float getX() -> v
    float getY() -> w
    void rotate90(boolean) -> x
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> y
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.SpriteBatch -> j.k:
    int blendSrcFuncAlpha -> n
    int blendDstFuncAlpha -> o
    int blendSrcFunc -> l
    int blendDstFunc -> m
    float invTexHeight -> f
    boolean blendingDisabled -> k
    float invTexWidth -> e
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> p
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> q
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> j
    float[] vertices -> b
    int idx -> c
    boolean ownsShader -> r
    com.badlogic.gdx.graphics.Mesh mesh -> a
    com.badlogic.gdx.graphics.Texture lastTexture -> d
    com.badlogic.gdx.math.Matrix4 transformMatrix -> h
    float colorPacked -> t
    int totalRenderCalls -> v
    int maxSpritesInBatch -> w
    boolean drawing -> g
    com.badlogic.gdx.graphics.Mesh$VertexDataType defaultVertexDataType -> x
    int renderCalls -> u
    com.badlogic.gdx.graphics.Color color -> s
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float,float,int,int,int,int,boolean,boolean) -> A
    void setColor(float,float,float,float) -> B
    boolean isBlendingEnabled() -> E
    void setupMatrices() -> G
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> H
    void setPackedColor(float) -> I
    float getPackedColor() -> J
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> Q
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> S
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> U
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> V
    void dispose() -> a
    void end() -> e
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> j
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> k
    void setColor(com.badlogic.gdx.graphics.Color) -> l
    com.badlogic.gdx.graphics.Color getColor() -> n
    void draw(com.badlogic.gdx.graphics.Texture,float,float) -> o
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float) -> p
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> q
    void begin() -> w
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> y
com.badlogic.gdx.graphics.g2d.TextureAtlas -> j.l:
    com.badlogic.gdx.utils.ObjectSet textures -> a
    com.badlogic.gdx.utils.Array regions -> b
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> A
    com.badlogic.gdx.graphics.g2d.Sprite newSprite(com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion) -> E
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.Sprite createSprite(java.lang.String) -> k
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion findRegion(java.lang.String) -> o
    com.badlogic.gdx.utils.Array getRegions() -> p
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> j.l$a:
    int originalWidth -> n
    int[][] values -> s
    float offsetY -> k
    int originalHeight -> o
    java.lang.String name -> i
    float offsetX -> j
    int packedWidth -> l
    int packedHeight -> m
    boolean rotate -> p
    int index -> h
    int degrees -> q
    java.lang.String[] names -> r
    void flip(boolean,boolean) -> a
    int[] findValue(java.lang.String) -> o
    float getRotatedPackedHeight() -> p
    float getRotatedPackedWidth() -> q
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> j.l$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> t
    float originalOffsetY -> v
    float originalOffsetX -> u
    void setOrigin(float,float) -> C
    void setSize(float,float) -> G
    float getHeightRatio() -> I
    float getWidthRatio() -> J
    void flip(boolean,boolean) -> a
    float getHeight() -> q
    float getOriginX() -> r
    float getOriginY() -> s
    float getWidth() -> u
    float getX() -> v
    float getY() -> w
    void rotate90(boolean) -> x
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> j.l$c:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getPages() -> a
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle,boolean) -> b
    int readEntry(java.lang.String[],java.lang.String) -> c
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$1 -> j.l$c$f:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$10 -> j.l$c$a:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$11 -> j.l$c$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$12 -> j.l$c$c:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$13 -> j.l$c$d:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> c
    boolean[] val$hasIndexes -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$14 -> j.l$c$e:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> a
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$2 -> j.l$c$g:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$3 -> j.l$c$h:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$4 -> j.l$c$i:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$5 -> j.l$c$j:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$6 -> j.l$c$k:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$7 -> j.l$c$l:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$8 -> j.l$c$m:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$9 -> j.l$c$n:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Field -> j.l$c$o:
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> j.l$c$p:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    boolean pma -> k
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
    float width -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture texture -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> j.l$c$q:
    int index -> m
    boolean flip -> p
    float offsetY -> h
    int originalHeight -> j
    float offsetX -> g
    int degrees -> k
    int originalWidth -> i
    boolean rotate -> l
    int height -> f
    int top -> d
    int width -> e
    int left -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    java.lang.String[] names -> n
    int[][] values -> o
    java.lang.String name -> b
com.badlogic.gdx.graphics.g2d.TextureRegion -> j.m:
    float v2 -> e
    float u2 -> d
    int regionWidth -> f
    float v -> c
    int regionHeight -> g
    float u -> b
    com.badlogic.gdx.graphics.Texture texture -> a
    void flip(boolean,boolean) -> a
    int getRegionHeight() -> b
    int getRegionWidth() -> c
    int getRegionX() -> d
    int getRegionY() -> e
    com.badlogic.gdx.graphics.Texture getTexture() -> f
    float getU() -> g
    float getU2() -> h
    float getV() -> i
    float getV2() -> j
    void setRegion(float,float,float,float) -> k
    void setRegion(int,int,int,int) -> l
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> m
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> n
com.badlogic.gdx.graphics.g3d.Attribute -> k.a:
    long type -> a
    com.badlogic.gdx.utils.Array types -> c
    int typeBit -> b
    boolean equals(com.badlogic.gdx.graphics.g3d.Attribute) -> a
    java.lang.String getAttributeAlias(long) -> b
    long getAttributeType(java.lang.String) -> c
    long register(java.lang.String) -> d
com.badlogic.gdx.graphics.g3d.Attributes -> k.b:
    long mask -> a
    com.badlogic.gdx.utils.Array attributes -> b
    boolean sorted -> c
    int attributesHash() -> a
    int compare(com.badlogic.gdx.graphics.g3d.Attribute,com.badlogic.gdx.graphics.g3d.Attribute) -> b
    int compareTo(com.badlogic.gdx.graphics.g3d.Attributes) -> c
    void enable(long) -> d
    boolean has(long) -> e
    int indexOf(long) -> f
    boolean same(com.badlogic.gdx.graphics.g3d.Attributes,boolean) -> g
    void set(com.badlogic.gdx.graphics.g3d.Attribute) -> h
    void sort() -> i
com.badlogic.gdx.graphics.g3d.Material -> k.c:
    int counter -> e
    java.lang.String id -> d
com.badlogic.gdx.graphics.g3d.Model -> k.d:
    com.badlogic.gdx.utils.ObjectMap nodePartBones -> g
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.utils.Array meshParts -> e
    com.badlogic.gdx.utils.Array meshes -> d
    com.badlogic.gdx.utils.Array animations -> c
    com.badlogic.gdx.utils.Array nodes -> b
    com.badlogic.gdx.utils.Array disposables -> f
    java.lang.Iterable getManagedDisposables() -> A
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String) -> E
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean) -> G
    com.badlogic.gdx.graphics.g3d.model.Node getNode(java.lang.String,boolean,boolean) -> Q
    void load(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> W
    void loadAnimations(java.lang.Iterable) -> X
    void loadMaterials(java.lang.Iterable,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> Y
    void loadMeshes(java.lang.Iterable) -> Z
    void dispose() -> a
    com.badlogic.gdx.graphics.g3d.model.Node loadNode(com.badlogic.gdx.graphics.g3d.model.data.ModelNode) -> a0
    void loadNodes(java.lang.Iterable) -> b0
    void calculateTransforms() -> k
    com.badlogic.gdx.graphics.g3d.Material convertMaterial(com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial,com.badlogic.gdx.graphics.g3d.utils.TextureProvider) -> o
    void convertMesh(com.badlogic.gdx.graphics.g3d.model.data.ModelMesh) -> p
com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute -> l.a:
    float opacity -> g
    long Type -> h
    int destFunction -> f
    int sourceFunction -> e
    boolean blended -> d
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> e
com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute -> l.b:
    long AmbientLight -> j
    com.badlogic.gdx.graphics.Color color -> d
    long Reflection -> i
    long Mask -> l
    long Fog -> k
    long Specular -> f
    long Diffuse -> e
    long Emissive -> h
    long Ambient -> g
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> e
    boolean is(long) -> f
com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute -> l.c:
    long AlphaTest -> f
    long Shininess -> e
    float value -> d
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> e
com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute -> l.d:
    long Diffuse -> j
    long Bump -> l
    com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor textureDescription -> d
    long Specular -> k
    float scaleV -> h
    float scaleU -> g
    float offsetV -> f
    float offsetU -> e
    int uvIndex -> i
    long Mask -> q
    long Ambient -> n
    long Normal -> m
    long Reflection -> p
    long Emissive -> o
    int compareTo(com.badlogic.gdx.graphics.g3d.Attribute) -> e
    boolean is(long) -> f
com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader -> m.a:
    com.badlogic.gdx.utils.BaseJsonReader reader -> d
    com.badlogic.gdx.math.Quaternion tempQ -> e
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> h
    void parseAnimations(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> j
    com.badlogic.gdx.graphics.VertexAttribute[] parseAttributes(com.badlogic.gdx.utils.JsonValue) -> k
    com.badlogic.gdx.graphics.Color parseColor(com.badlogic.gdx.utils.JsonValue) -> l
    void parseMaterials(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue,java.lang.String) -> m
    void parseMeshes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> n
    com.badlogic.gdx.graphics.g3d.model.data.ModelData parseModel(com.badlogic.gdx.files.FileHandle) -> o
    com.badlogic.gdx.utils.Array parseNodes(com.badlogic.gdx.graphics.g3d.model.data.ModelData,com.badlogic.gdx.utils.JsonValue) -> p
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode parseNodesRecursively(com.badlogic.gdx.utils.JsonValue) -> q
    int parseTextureUsage(java.lang.String) -> r
    int parseType(java.lang.String) -> s
    com.badlogic.gdx.math.Vector2 readVector2(com.badlogic.gdx.utils.JsonValue,float,float) -> t
com.badlogic.gdx.graphics.g3d.loader.MtlLoader -> m.b:
    com.badlogic.gdx.utils.Array materials -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial getMaterial(java.lang.String) -> a
    void load(com.badlogic.gdx.files.FileHandle) -> b
    com.badlogic.gdx.graphics.Color parseColor(java.lang.String[]) -> c
com.badlogic.gdx.graphics.g3d.loader.MtlLoader$ObjMaterial -> m.b$a:
    java.lang.String alphaTexFilename -> g
    com.badlogic.gdx.graphics.Color specularColor -> d
    java.lang.String diffuseTexFilename -> i
    java.lang.String ambientTexFilename -> h
    java.lang.String specularTexFilename -> k
    java.lang.String shininessTexFilename -> j
    float shininess -> f
    float opacity -> e
    java.lang.String materialName -> a
    com.badlogic.gdx.graphics.Color diffuseColor -> c
    com.badlogic.gdx.graphics.Color ambientColor -> b
    void addTexture(com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial,java.lang.String,int) -> a
    com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial build() -> b
    void reset() -> c
com.badlogic.gdx.graphics.g3d.loader.ObjLoader -> m.c:
    com.badlogic.gdx.utils.FloatArray uvs -> f
    com.badlogic.gdx.utils.FloatArray verts -> d
    com.badlogic.gdx.utils.FloatArray norms -> e
    boolean logWarning -> h
    com.badlogic.gdx.utils.Array groups -> g
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.ModelLoader$ModelParameters) -> h
    int getIndex(java.lang.String,int) -> j
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters) -> k
    com.badlogic.gdx.graphics.g3d.model.data.ModelData loadModelData(com.badlogic.gdx.files.FileHandle,boolean) -> l
    com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group setActiveGroup(java.lang.String) -> m
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$Group -> m.c$a:
    com.badlogic.gdx.graphics.g3d.Material mat -> g
    boolean hasNorms -> e
    boolean hasUVs -> f
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array faces -> c
    int numFaces -> d
    java.lang.String materialName -> b
com.badlogic.gdx.graphics.g3d.loader.ObjLoader$ObjLoaderParameters -> m.c$b:
    boolean flipV -> c
com.badlogic.gdx.graphics.g3d.model.Animation -> n.a:
    java.lang.String id -> a
    float duration -> b
    com.badlogic.gdx.utils.Array nodeAnimations -> c
com.badlogic.gdx.graphics.g3d.model.MeshPart -> n.b:
    com.badlogic.gdx.graphics.Mesh mesh -> e
    float radius -> h
    java.lang.String id -> a
    int size -> d
    com.badlogic.gdx.math.collision.BoundingBox bounds -> i
    int primitiveType -> b
    int offset -> c
    com.badlogic.gdx.math.Vector3 center -> f
    com.badlogic.gdx.math.Vector3 halfExtents -> g
    boolean equals(com.badlogic.gdx.graphics.g3d.model.MeshPart) -> a
    void update() -> b
com.badlogic.gdx.graphics.g3d.model.Node -> n.c:
    com.badlogic.gdx.math.Vector3 translation -> d
    com.badlogic.gdx.utils.Array children -> k
    com.badlogic.gdx.math.Matrix4 localTransform -> g
    com.badlogic.gdx.math.Matrix4 globalTransform -> h
    com.badlogic.gdx.math.Quaternion rotation -> e
    com.badlogic.gdx.graphics.g3d.model.Node parent -> j
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array parts -> i
    boolean inheritTransform -> b
    boolean isAnimated -> c
    com.badlogic.gdx.math.Vector3 scale -> f
    int addChild(com.badlogic.gdx.graphics.g3d.model.Node) -> a
    void calculateBoneTransforms(boolean) -> b
    com.badlogic.gdx.math.Matrix4 calculateLocalTransform() -> c
    void calculateTransforms(boolean) -> d
    com.badlogic.gdx.math.Matrix4 calculateWorldTransform() -> e
    com.badlogic.gdx.graphics.g3d.model.Node getNode(com.badlogic.gdx.utils.Array,java.lang.String,boolean,boolean) -> f
    com.badlogic.gdx.graphics.g3d.model.Node getParent() -> g
    int insertChild(int,com.badlogic.gdx.graphics.g3d.model.Node) -> h
    boolean removeChild(com.badlogic.gdx.graphics.g3d.model.Node) -> i
com.badlogic.gdx.graphics.g3d.model.NodeAnimation -> n.d:
    com.badlogic.gdx.graphics.g3d.model.Node node -> a
    com.badlogic.gdx.utils.Array scaling -> d
    com.badlogic.gdx.utils.Array rotation -> c
    com.badlogic.gdx.utils.Array translation -> b
com.badlogic.gdx.graphics.g3d.model.NodeKeyframe -> n.e:
    java.lang.Object value -> b
    float keytime -> a
com.badlogic.gdx.graphics.g3d.model.NodePart -> n.f:
    com.badlogic.gdx.utils.ArrayMap invBoneBindTransforms -> c
    boolean enabled -> e
    com.badlogic.gdx.graphics.g3d.model.MeshPart meshPart -> a
    com.badlogic.gdx.graphics.g3d.Material material -> b
    com.badlogic.gdx.math.Matrix4[] bones -> d
com.badlogic.gdx.graphics.g3d.model.data.ModelAnimation -> o.a:
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array nodeAnimations -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelData -> o.b:
    com.badlogic.gdx.utils.Array nodes -> e
    com.badlogic.gdx.utils.Array materials -> d
    java.lang.String id -> a
    short[] version -> b
    com.badlogic.gdx.utils.Array meshes -> c
    com.badlogic.gdx.utils.Array animations -> f
com.badlogic.gdx.graphics.g3d.model.data.ModelMaterial -> o.c:
    com.badlogic.gdx.graphics.Color emissive -> e
    com.badlogic.gdx.graphics.Color specular -> d
    com.badlogic.gdx.graphics.Color reflection -> f
    float opacity -> h
    float shininess -> g
    java.lang.String id -> a
    com.badlogic.gdx.utils.Array textures -> i
    com.badlogic.gdx.graphics.Color diffuse -> c
    com.badlogic.gdx.graphics.Color ambient -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelMesh -> o.d:
    com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart[] parts -> d
    java.lang.String id -> a
    float[] vertices -> c
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelMeshPart -> o.e:
    java.lang.String id -> a
    short[] indices -> b
    int primitiveType -> c
com.badlogic.gdx.graphics.g3d.model.data.ModelNode -> o.f:
    com.badlogic.gdx.math.Vector3 scale -> d
    com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart[] parts -> f
    com.badlogic.gdx.math.Vector3 translation -> b
    com.badlogic.gdx.math.Quaternion rotation -> c
    com.badlogic.gdx.graphics.g3d.model.data.ModelNode[] children -> g
    java.lang.String id -> a
    java.lang.String meshId -> e
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeAnimation -> o.g:
    com.badlogic.gdx.utils.Array scaling -> d
    java.lang.String nodeId -> a
    com.badlogic.gdx.utils.Array rotation -> c
    com.badlogic.gdx.utils.Array translation -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelNodeKeyframe -> o.h:
    java.lang.Object value -> b
    float keytime -> a
com.badlogic.gdx.graphics.g3d.model.data.ModelNodePart -> o.i:
    com.badlogic.gdx.utils.ArrayMap bones -> c
    java.lang.String materialId -> a
    java.lang.String meshPartId -> b
com.badlogic.gdx.graphics.g3d.model.data.ModelTexture -> o.j:
    com.badlogic.gdx.math.Vector2 uvTranslation -> c
    com.badlogic.gdx.math.Vector2 uvScaling -> d
    java.lang.String id -> a
    int usage -> e
    java.lang.String fileName -> b
com.badlogic.gdx.graphics.g3d.particles.ParticleController -> p.a:
    com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer renderer -> d
    float deltaTimeSqr -> h
    float deltaTime -> g
    com.badlogic.gdx.math.Matrix4 transform -> e
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array influencers -> c
    com.badlogic.gdx.math.Vector3 scale -> f
    com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter emitter -> b
    void dispose() -> a
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> b
    void setTimeStep(float) -> c
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent -> p.b:
    com.badlogic.gdx.math.Vector3 TMP_V4 -> d
    com.badlogic.gdx.math.Quaternion TMP_Q -> g
    com.badlogic.gdx.math.Vector3 TMP_V5 -> e
    com.badlogic.gdx.math.Vector3 TMP_V2 -> b
    com.badlogic.gdx.math.Vector3 TMP_V3 -> c
    com.badlogic.gdx.math.Quaternion TMP_Q2 -> h
    com.badlogic.gdx.math.Vector3 TMP_V1 -> a
    com.badlogic.gdx.math.Matrix3 TMP_M3 -> i
    com.badlogic.gdx.math.Matrix4 TMP_M4 -> j
    com.badlogic.gdx.math.Vector3 TMP_V6 -> f
    void dispose() -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> o
com.badlogic.gdx.graphics.g3d.particles.ParticleEffect -> p.c:
    com.badlogic.gdx.utils.Array controllers -> a
    void dispose() -> a
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> k
    void setBatch(com.badlogic.gdx.utils.Array) -> o
com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader -> p.d:
    com.badlogic.gdx.utils.Array items -> b
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> f
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> g
    com.badlogic.gdx.graphics.g3d.particles.ParticleEffect loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter) -> h
com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader$ParticleEffectLoadParameter -> p.d$a:
    com.badlogic.gdx.utils.Array batches -> b
com.badlogic.gdx.graphics.g3d.particles.ResourceData -> p.e:
    java.lang.Object resource -> e
    com.badlogic.gdx.utils.ObjectMap uniqueData -> a
    com.badlogic.gdx.utils.Array sharedAssets -> c
    int currentLoadIndex -> d
    com.badlogic.gdx.utils.Array data -> b
    com.badlogic.gdx.utils.Array getAssets() -> a
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.graphics.g3d.particles.ResourceData$AssetData -> p.e$a:
    java.lang.String filename -> a
    java.lang.Class type -> b
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.graphics.g3d.particles.ResourceData$SaveData -> p.e$b:
    com.badlogic.gdx.utils.IntArray assets -> b
    com.badlogic.gdx.graphics.g3d.particles.ResourceData resources -> d
    com.badlogic.gdx.utils.ObjectMap data -> a
    int loadIndex -> c
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch -> q.a:
    void load(com.badlogic.gdx.assets.AssetManager,com.badlogic.gdx.graphics.g3d.particles.ResourceData) -> a
com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter -> r.a:
    int maxParticleCount -> l
    int minParticleCount -> k
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.graphics.g3d.particles.influencers.Influencer -> s.a:
com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer -> t.a:
    com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch batch -> k
    boolean setBatch(com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch) -> A
    boolean isCompatible(com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch) -> p
com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor -> u.a:
    com.badlogic.gdx.graphics.GLTexture texture -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> c
    int compareTo(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> a
    void set(com.badlogic.gdx.graphics.GLTexture,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> b
    void set(com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor) -> c
com.badlogic.gdx.graphics.g3d.utils.TextureProvider -> u.b:
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.g3d.utils.TextureProvider$AssetTextureProvider -> u.b$a:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.Texture load(java.lang.String) -> a
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int ETC1_RGB8_OES -> b
    int PKM_HEADER_SIZE -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.ETC1$a:
    int dataOffset -> d
    java.nio.ByteBuffer compressedData -> c
    int height -> b
    int width -> a
    void dispose() -> a
    void checkNPOT() -> k
    boolean hasPKMHeader() -> o
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.a:
    com.badlogic.gdx.files.FileHandle file -> a
    boolean isPrepared -> f
    int width -> d
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    int height -> e
    boolean useMipMaps -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    boolean disposePixmap() -> h
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> i
    boolean useMipMaps() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.glutils.FileTextureData -> v.a:
    com.badlogic.gdx.graphics.Pixmap pixmap -> e
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> d
    boolean useMipMaps -> f
    boolean isPrepared -> g
    int width -> b
    int height -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    boolean disposePixmap() -> h
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> i
    boolean useMipMaps() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
com.badlogic.gdx.graphics.glutils.GLFrameBuffer -> v.b:
    com.badlogic.gdx.utils.Array textureAttachments -> a
    int defaultFramebufferHandle -> f
    boolean defaultFramebufferHandleInitialized -> g
    int framebufferHandle -> b
    java.util.Map buffers -> e
    int depthStencilPackedBufferHandle -> c
    boolean hasDepthStencilPackedBuffer -> d
    void disposeColorTexture(com.badlogic.gdx.graphics.GLTexture) -> A
    java.lang.String getManagedStatus() -> E
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> G
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> Q
    void dispose() -> a
    void build() -> k
    void checkValidBuilder() -> o
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> p
com.badlogic.gdx.graphics.glutils.GLVersion -> v.c:
    java.lang.String TAG -> g
    int minorVersion -> b
    int releaseVersion -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type type -> f
    java.lang.String rendererString -> e
    int majorVersion -> a
    java.lang.String vendorString -> d
    void extractVersion(java.lang.String,java.lang.String) -> a
    int getMajorVersion() -> b
    int parseInt(java.lang.String,int) -> c
com.badlogic.gdx.graphics.glutils.GLVersion$Type -> v.c$a:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type WebGL -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type GLES -> b
    com.badlogic.gdx.graphics.glutils.GLVersion$Type NONE -> d
    com.badlogic.gdx.graphics.glutils.GLVersion$Type OpenGL -> a
    com.badlogic.gdx.graphics.glutils.GLVersion$Type[] $VALUES -> e
com.badlogic.gdx.graphics.glutils.HdpiMode -> v.d:
    com.badlogic.gdx.graphics.glutils.HdpiMode Pixels -> b
    com.badlogic.gdx.graphics.glutils.HdpiMode Logical -> a
    com.badlogic.gdx.graphics.glutils.HdpiMode[] $VALUES -> c
com.badlogic.gdx.graphics.glutils.HdpiUtils -> v.e:
    com.badlogic.gdx.graphics.glutils.HdpiMode mode -> a
    void glScissor(int,int,int,int) -> a
    void glViewport(int,int,int,int) -> b
    int toBackBufferX(int) -> c
    int toBackBufferY(int) -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> v.g:
    void dispose() -> a
    void end() -> e
    int getNumVertices() -> h
    int getMaxVertices() -> i
    void color(float) -> j
    void color(float,float,float,float) -> k
    void vertex(float,float,float) -> l
    void begin(com.badlogic.gdx.math.Matrix4,int) -> m
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> v.f:
    int colorOffset -> l
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    int texCoordOffset -> m
    int vertexSize -> j
    int normalOffset -> k
    int numTexCoords -> i
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    int vertexIdx -> b
    int numSetTexCoords -> c
    int primitiveType -> a
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    boolean ownsShader -> h
    java.lang.String[] shaderUniformNames -> p
    float[] vertices -> o
    void dispose() -> a
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> b
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> c
    java.lang.String createFragmentShader(boolean,boolean,int) -> d
    void end() -> e
    java.lang.String createVertexShader(boolean,boolean,int) -> f
    void flush() -> g
    int getNumVertices() -> h
    int getMaxVertices() -> i
    void color(float) -> j
    void color(float,float,float,float) -> k
    void vertex(float,float,float) -> l
    void begin(com.badlogic.gdx.math.Matrix4,int) -> m
com.badlogic.gdx.graphics.glutils.IndexArray -> v.h:
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    boolean empty -> c
    int getNumIndices() -> D
    void unbind() -> L
    void setIndices(short[],int,int) -> N
    void dispose() -> a
    java.nio.ShortBuffer getBuffer() -> g
    void invalidate() -> i
    int getNumMaxIndices() -> u
    void bind() -> x
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> v.i:
    boolean empty -> i
    int usage -> h
    boolean isDirect -> e
    boolean isDirty -> f
    java.nio.ShortBuffer buffer -> a
    int bufferHandle -> d
    boolean isBound -> g
    java.nio.ByteBuffer byteBuffer -> b
    boolean ownsBuffer -> c
    int getNumIndices() -> D
    void unbind() -> L
    void setIndices(short[],int,int) -> N
    void dispose() -> a
    java.nio.ShortBuffer getBuffer() -> g
    void invalidate() -> i
    int getNumMaxIndices() -> u
    void bind() -> x
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> v.j:
    boolean isDirty -> e
    boolean isBound -> f
    int usage -> g
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    int bufferHandle -> c
    boolean isDirect -> d
    int getNumIndices() -> D
    void unbind() -> L
    void setIndices(short[],int,int) -> N
    void dispose() -> a
    java.nio.ShortBuffer getBuffer() -> g
    void invalidate() -> i
    int createBufferObject() -> k
    int getNumMaxIndices() -> u
    void bind() -> x
com.badlogic.gdx.graphics.glutils.IndexData -> v.k:
    int getNumIndices() -> D
    void unbind() -> L
    void setIndices(short[],int,int) -> N
    void dispose() -> a
    java.nio.ShortBuffer getBuffer() -> g
    void invalidate() -> i
    int getNumMaxIndices() -> u
    void bind() -> x
com.badlogic.gdx.graphics.glutils.InstanceData -> v.l:
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    int getNumInstances() -> m
com.badlogic.gdx.graphics.glutils.KTXTextureData -> com.badlogic.gdx.graphics.glutils.b:
    java.nio.ByteBuffer compressedData -> n
    com.badlogic.gdx.files.FileHandle file -> a
    int numberOfMipmapLevels -> l
    boolean useMipMaps -> o
    int imagePos -> m
    int numberOfArrayElements -> j
    int numberOfFaces -> k
    int pixelHeight -> h
    int pixelDepth -> i
    int glBaseInternalFormat -> f
    int pixelWidth -> g
    int glFormat -> d
    int glInternalFormat -> e
    int glType -> b
    int glTypeSize -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCubemapData() -> g
    boolean disposePixmap() -> h
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> i
    boolean useMipMaps() -> j
    void consumeCustomData(int) -> k
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> l
    void disposePreparedData() -> m
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> v.m:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> d
com.badlogic.gdx.graphics.glutils.ShaderProgram -> v.n:
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> i
    int vertexShaderHandle -> l
    com.badlogic.gdx.utils.ObjectIntMap attributes -> g
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> e
    boolean pedantic -> u
    java.nio.IntBuffer type -> t
    java.lang.String fragmentShaderSource -> p
    boolean invalidated -> q
    java.lang.String prependVertexCode -> v
    java.lang.String[] attributeNames -> j
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> d
    java.lang.String log -> a
    boolean isCompiled -> b
    int fragmentShaderHandle -> m
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> h
    int program -> k
    java.lang.String vertexShaderSource -> o
    java.nio.IntBuffer params -> s
    java.lang.String[] uniformNames -> f
    java.nio.IntBuffer intbuf -> y
    java.lang.String prependFragmentCode -> w
    com.badlogic.gdx.utils.ObjectMap shaders -> x
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> c
    java.nio.FloatBuffer matrix -> n
    int refCount -> r
    void compileShaders(java.lang.String,java.lang.String) -> A
    int createProgram() -> E
    void disableVertexAttribute(int) -> G
    void disableVertexAttribute(java.lang.String) -> Q
    void enableVertexAttribute(int) -> W
    int fetchAttributeLocation(java.lang.String) -> X
    void fetchAttributes() -> Y
    int fetchUniformLocation(java.lang.String) -> Z
    void dispose() -> a
    int fetchUniformLocation(java.lang.String,boolean) -> a0
    void fetchUniforms() -> b0
    int getAttributeLocation(java.lang.String) -> c0
    java.lang.String getLog() -> d0
    java.lang.String getManagedStatus() -> e0
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> f0
    boolean isCompiled() -> g0
    int linkProgram(int) -> h0
    int loadShader(int,java.lang.String) -> i0
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4,boolean) -> j0
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> k
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> k0
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> l0
    void setUniformi(java.lang.String,int) -> m0
    void setVertexAttribute(int,int,int,boolean,int,int) -> n0
    void checkManaged() -> o
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> o0
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> p
    void bind() -> x
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> v.o:
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.graphics.Color color -> g
    float defaultRectLineWidth -> j
    boolean autoShapeType -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> h
    com.badlogic.gdx.math.Vector2 tmp -> f
    void rect(float,float,float,float) -> A
    void rect(float,float,float,float,float,float,float,float,float) -> E
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> G
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> Q
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> V
    void setAutoShapeType(boolean) -> W
    void dispose() -> a
    void end() -> e
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> j
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> k
    void setColor(com.badlogic.gdx.graphics.Color) -> l
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> o
    boolean isDrawing() -> p
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> q
    void begin() -> w
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> v.o$a:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> c
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> b
    int glType -> a
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> v.p:
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean isBound -> d
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> O
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    java.nio.FloatBuffer getBuffer() -> g
    int getNumVertices() -> h
    void invalidate() -> i
    void setVertices(float[],int,int) -> v
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> v.q:
    java.nio.FloatBuffer buffer -> b
    int usage -> f
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> O
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    java.nio.FloatBuffer getBuffer() -> g
    int getNumVertices() -> h
    void invalidate() -> i
    void bufferChanged() -> k
    void setBuffer(java.nio.Buffer,boolean,com.badlogic.gdx.graphics.VertexAttributes) -> o
    void setUsage(int) -> p
    void setVertices(float[],int,int) -> v
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> v.r:
    java.nio.FloatBuffer buffer -> b
    boolean isBound -> i
    boolean isDirect -> e
    boolean isStatic -> f
    int usage -> g
    int bufferHandle -> d
    java.nio.ByteBuffer byteBuffer -> c
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> O
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    java.nio.FloatBuffer getBuffer() -> g
    int getNumVertices() -> h
    void invalidate() -> i
    void bufferChanged() -> k
    int createBufferObject() -> o
    void setVertices(float[],int,int) -> v
com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO -> v.s:
    java.nio.FloatBuffer buffer -> b
    java.nio.IntBuffer tmpHandle -> l
    com.badlogic.gdx.utils.IntArray cachedLocations -> k
    boolean isBound -> i
    int vaoHandle -> j
    boolean isStatic -> f
    int usage -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void createVAO() -> A
    void deleteVAO() -> E
    void unbindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> G
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> O
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    java.nio.FloatBuffer getBuffer() -> g
    int getNumVertices() -> h
    void invalidate() -> i
    void bindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> k
    void bindData(com.badlogic.gdx.graphics.GL20) -> o
    void bufferChanged() -> p
    void setVertices(float[],int,int) -> v
com.badlogic.gdx.graphics.glutils.VertexData -> v.t:
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> O
    void dispose() -> a
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> d
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> f
    java.nio.FloatBuffer getBuffer() -> g
    int getNumVertices() -> h
    void invalidate() -> i
    void setVertices(float[],int,int) -> v
com.badlogic.gdx.maps.ImageResolver -> w.a:
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.ImageResolver$AssetManagerImageResolver -> w.a$a:
    com.badlogic.gdx.assets.AssetManager assetManager -> a
    com.badlogic.gdx.graphics.g2d.TextureRegion getImage(java.lang.String) -> a
com.badlogic.gdx.maps.Map -> w.b:
    com.badlogic.gdx.maps.MapLayers layers -> a
    com.badlogic.gdx.maps.MapProperties properties -> b
    com.badlogic.gdx.maps.MapLayers getLayers() -> k
    com.badlogic.gdx.maps.MapProperties getProperties() -> o
com.badlogic.gdx.maps.MapGroupLayer -> w.c:
    com.badlogic.gdx.maps.MapLayers layers -> l
    void invalidateRenderOffset() -> h
    com.badlogic.gdx.maps.MapLayers getLayers() -> o
com.badlogic.gdx.maps.MapLayer -> w.d:
    com.badlogic.gdx.maps.MapProperties properties -> k
    float renderOffsetY -> g
    float renderOffsetX -> f
    float offsetY -> e
    float offsetX -> d
    com.badlogic.gdx.maps.MapLayer parent -> i
    com.badlogic.gdx.maps.MapObjects objects -> j
    java.lang.String name -> a
    float opacity -> b
    boolean renderOffsetDirty -> h
    boolean visible -> c
    void calculateRenderOffsets() -> a
    java.lang.String getName() -> b
    com.badlogic.gdx.maps.MapObjects getObjects() -> c
    float getOpacity() -> d
    com.badlogic.gdx.maps.MapProperties getProperties() -> e
    float getRenderOffsetX() -> f
    float getRenderOffsetY() -> g
    void invalidateRenderOffset() -> h
    void setName(java.lang.String) -> i
    void setOffsetX(float) -> j
    void setOffsetY(float) -> k
    void setOpacity(float) -> l
    void setParent(com.badlogic.gdx.maps.MapLayer) -> m
    void setVisible(boolean) -> n
com.badlogic.gdx.maps.MapLayers -> w.e:
    com.badlogic.gdx.utils.Array layers -> a
    void add(com.badlogic.gdx.maps.MapLayer) -> a
    com.badlogic.gdx.maps.MapLayer get(int) -> b
    com.badlogic.gdx.maps.MapLayer get(java.lang.String) -> c
    int size() -> d
com.badlogic.gdx.maps.MapObject -> w.f:
    com.badlogic.gdx.graphics.Color color -> e
    com.badlogic.gdx.maps.MapProperties properties -> d
    java.lang.String name -> a
    float opacity -> b
    boolean visible -> c
    java.lang.String getName() -> a
    com.badlogic.gdx.maps.MapProperties getProperties() -> b
    void setName(java.lang.String) -> c
    void setVisible(boolean) -> d
com.badlogic.gdx.maps.MapObjects -> w.g:
    com.badlogic.gdx.utils.Array objects -> a
    void add(com.badlogic.gdx.maps.MapObject) -> a
    com.badlogic.gdx.maps.MapObject get(int) -> b
    int getCount() -> c
com.badlogic.gdx.maps.MapProperties -> w.h:
    com.badlogic.gdx.utils.ObjectMap properties -> a
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> b
    void put(java.lang.String,java.lang.Object) -> c
com.badlogic.gdx.maps.objects.EllipseMapObject -> x.a:
    com.badlogic.gdx.math.Ellipse ellipse -> f
    com.badlogic.gdx.math.Ellipse getEllipse() -> e
com.badlogic.gdx.maps.objects.PolygonMapObject -> x.b:
    com.badlogic.gdx.math.Polygon polygon -> f
com.badlogic.gdx.maps.objects.PolylineMapObject -> x.c:
    com.badlogic.gdx.math.Polyline polyline -> f
com.badlogic.gdx.maps.objects.RectangleMapObject -> x.d:
    com.badlogic.gdx.math.Rectangle rectangle -> f
    com.badlogic.gdx.math.Rectangle getRectangle() -> e
com.badlogic.gdx.maps.objects.TextureMapObject -> x.e:
    float rotation -> l
    float scaleY -> k
    float scaleX -> j
    float originY -> i
    float originX -> h
    float y -> g
    float x -> f
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> m
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> e
    void setRotation(float) -> f
    void setScaleX(float) -> g
    void setScaleY(float) -> h
    void setTextureRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> i
    void setX(float) -> j
    void setY(float) -> k
com.badlogic.gdx.maps.tiled.BaseTmxMapLoader -> y.a:
    com.badlogic.gdx.maps.tiled.TiledMap map -> j
    com.badlogic.gdx.utils.XmlReader xml -> b
    int mapWidthInPixels -> h
    com.badlogic.gdx.utils.XmlReader$Element root -> c
    int mapHeightInPixels -> i
    boolean flipY -> e
    int mapTileWidth -> f
    int mapTileHeight -> g
    boolean convertObjectToTileSpace -> d
    void loadTileSet(com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> A
    com.badlogic.gdx.maps.tiled.TiledMap loadTiledMap(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.tiled.BaseTmxMapLoader$Parameters,com.badlogic.gdx.maps.ImageResolver) -> B
    int unsignedByteToInt(byte) -> C
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> a
    void addStaticTiledMapTile(com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.graphics.g2d.TextureRegion,int,float,float) -> f
    void addStaticTiles(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver,com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.utils.Array,java.lang.String,int,int,int,int,int,java.lang.String,int,int,java.lang.String,int,int,com.badlogic.gdx.files.FileHandle) -> g
    void addTileObjectGroup(com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> h
    void addTileProperties(com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> i
    java.lang.Object castProperty(java.lang.String,java.lang.String,java.lang.String) -> j
    com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile createAnimatedTile(com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element,int) -> k
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell createTileLayerCell(boolean,boolean,boolean) -> l
    com.badlogic.gdx.utils.Array getDependencies(java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.tiled.BaseTmxMapLoader$Parameters) -> m
    com.badlogic.gdx.utils.Array getDependencyAssetDescriptors(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> n
    com.badlogic.gdx.files.FileHandle getRelativeFileHandle(com.badlogic.gdx.files.FileHandle,java.lang.String) -> o
    int[] getTileIds(com.badlogic.gdx.utils.XmlReader$Element,int,int) -> p
    void loadBasicLayerInfo(com.badlogic.gdx.maps.MapLayer,com.badlogic.gdx.utils.XmlReader$Element) -> q
    void loadImageLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> r
    void loadLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> s
    void loadLayerGroup(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver) -> t
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayer,com.badlogic.gdx.utils.XmlReader$Element) -> u
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapObjects,com.badlogic.gdx.utils.XmlReader$Element,float) -> v
    void loadObject(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.tiled.TiledMapTile,com.badlogic.gdx.utils.XmlReader$Element) -> w
    void loadObjectGroup(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element) -> x
    void loadProperties(com.badlogic.gdx.maps.MapProperties,com.badlogic.gdx.utils.XmlReader$Element) -> y
    void loadTileLayer(com.badlogic.gdx.maps.tiled.TiledMap,com.badlogic.gdx.maps.MapLayers,com.badlogic.gdx.utils.XmlReader$Element) -> z
com.badlogic.gdx.maps.tiled.BaseTmxMapLoader$Parameters -> y.a$a:
    boolean convertObjectToTileSpace -> e
    boolean flipY -> f
    boolean generateMipMaps -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMagFilter -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter textureMinFilter -> c
com.badlogic.gdx.maps.tiled.TiledMap -> y.b:
    com.badlogic.gdx.maps.tiled.TiledMapTileSets tilesets -> c
    com.badlogic.gdx.utils.Array ownedResources -> d
    void dispose() -> a
    com.badlogic.gdx.maps.tiled.TiledMapTileSets getTileSets() -> p
com.badlogic.gdx.maps.tiled.TiledMapImageLayer -> y.c:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> l
    float y -> n
    float x -> m
com.badlogic.gdx.maps.tiled.TiledMapTile -> y.d:
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setOffsetY(float) -> d
    com.badlogic.gdx.maps.MapObjects getObjects() -> e
    void setId(int) -> f
    com.badlogic.gdx.maps.MapProperties getProperties() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode -> y.d$a:
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode[] $VALUES -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode ALPHA -> b
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode NONE -> a
com.badlogic.gdx.maps.tiled.TiledMapTileLayer -> y.e:
    int tileWidth -> n
    int tileHeight -> o
    int width -> l
    int height -> m
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell[][] cells -> p
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell getCell(int,int) -> o
    int getHeight() -> p
    int getTileHeight() -> q
    int getTileWidth() -> r
    int getWidth() -> s
    void setCell(int,int,com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell) -> t
com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell -> y.e$a:
    com.badlogic.gdx.maps.tiled.TiledMapTile tile -> a
    int rotation -> d
    boolean flipHorizontally -> b
    boolean flipVertically -> c
    boolean getFlipHorizontally() -> a
    boolean getFlipVertically() -> b
    int getRotation() -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile() -> d
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setFlipHorizontally(boolean) -> e
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setFlipVertically(boolean) -> f
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setRotation(int) -> g
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer$Cell setTile(com.badlogic.gdx.maps.tiled.TiledMapTile) -> h
com.badlogic.gdx.maps.tiled.TiledMapTileSet -> y.f:
    java.lang.String name -> a
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.utils.IntMap tiles -> b
    com.badlogic.gdx.maps.MapProperties getProperties() -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> b
    void putTile(int,com.badlogic.gdx.maps.tiled.TiledMapTile) -> c
    void setName(java.lang.String) -> d
com.badlogic.gdx.maps.tiled.TiledMapTileSets -> y.g:
    com.badlogic.gdx.utils.Array tilesets -> a
    void addTileSet(com.badlogic.gdx.maps.tiled.TiledMapTileSet) -> a
    com.badlogic.gdx.maps.tiled.TiledMapTile getTile(int) -> b
com.badlogic.gdx.maps.tiled.TmxMapLoader -> y.h:
    com.badlogic.gdx.utils.Array getDependencyFileHandles(com.badlogic.gdx.files.FileHandle) -> D
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> E
    com.badlogic.gdx.maps.tiled.TiledMap loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters) -> F
    void loadAsync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> c
    java.lang.Object loadSync(com.badlogic.gdx.assets.AssetManager,java.lang.String,com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.AssetLoaderParameters) -> d
    void addStaticTiles(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.maps.ImageResolver,com.badlogic.gdx.maps.tiled.TiledMapTileSet,com.badlogic.gdx.utils.XmlReader$Element,com.badlogic.gdx.utils.Array,java.lang.String,int,int,int,int,int,java.lang.String,int,int,java.lang.String,int,int,com.badlogic.gdx.files.FileHandle) -> g
    com.badlogic.gdx.utils.Array getDependencyAssetDescriptors(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.assets.loaders.TextureLoader$TextureParameter) -> n
com.badlogic.gdx.maps.tiled.TmxMapLoader$Parameters -> y.h$a:
com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject -> z.a:
    boolean flipHorizontally -> n
    boolean flipVertically -> o
    com.badlogic.gdx.maps.tiled.TiledMapTile tile -> p
com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer -> a0.a:
    com.badlogic.gdx.math.Rectangle imageBounds -> e
    float[] vertices -> g
    com.badlogic.gdx.graphics.g2d.Batch batch -> c
    boolean ownsBatch -> f
    float unitScale -> b
    com.badlogic.gdx.maps.tiled.TiledMap map -> a
    com.badlogic.gdx.math.Rectangle viewBounds -> d
    void dispose() -> a
    void setView(com.badlogic.gdx.graphics.OrthographicCamera) -> k
com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer -> a0.b:
    void renderTileLayer(com.badlogic.gdx.maps.tiled.TiledMapTileLayer) -> o
com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile -> b0.a:
    com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile[] frameTiles -> e
    int[] animationIntervals -> f
    long initialTimeOffset -> i
    com.badlogic.gdx.maps.MapObjects objects -> d
    long lastTiledMapRenderTime -> h
    int loopDuration -> g
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode blendMode -> b
    int id -> a
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setOffsetY(float) -> d
    com.badlogic.gdx.maps.MapObjects getObjects() -> e
    void setId(int) -> f
    com.badlogic.gdx.maps.MapProperties getProperties() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
    com.badlogic.gdx.maps.tiled.TiledMapTile getCurrentFrame() -> j
    int getCurrentFrameIndex() -> k
com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile -> b0.b:
    com.badlogic.gdx.maps.MapObjects objects -> d
    com.badlogic.gdx.graphics.g2d.TextureRegion textureRegion -> e
    float offsetY -> g
    float offsetX -> f
    com.badlogic.gdx.maps.MapProperties properties -> c
    com.badlogic.gdx.maps.tiled.TiledMapTile$BlendMode blendMode -> b
    int id -> a
    float getOffsetX() -> a
    int getId() -> b
    void setOffsetX(float) -> c
    void setOffsetY(float) -> d
    com.badlogic.gdx.maps.MapObjects getObjects() -> e
    void setId(int) -> f
    com.badlogic.gdx.maps.MapProperties getProperties() -> g
    float getOffsetY() -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getTextureRegion() -> i
com.badlogic.gdx.math.Affine2 -> c0.a:
    float m12 -> f
    float m11 -> e
    float m10 -> d
    float m02 -> c
    float m01 -> b
    float m00 -> a
    com.badlogic.gdx.math.Affine2 preMul(com.badlogic.gdx.math.Affine2) -> a
    com.badlogic.gdx.math.Affine2 setToTrnRotScl(float,float,float,float,float) -> b
    com.badlogic.gdx.math.Affine2 translate(float,float) -> c
com.badlogic.gdx.math.EarClippingTriangulator -> c0.b:
    com.badlogic.gdx.utils.ShortArray triangles -> f
    com.badlogic.gdx.utils.ShortArray indicesArray -> a
    com.badlogic.gdx.utils.IntArray vertexTypes -> e
    short[] indices -> b
    float[] vertices -> c
    int vertexCount -> d
    int classifyVertex(int) -> a
    int computeSpannedAreaSign(float,float,float,float,float,float) -> b
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[]) -> c
    com.badlogic.gdx.utils.ShortArray computeTriangles(float[],int,int) -> d
    void cutEarTip(int) -> e
    int findEarTip() -> f
    boolean isEarTip(int) -> g
    int nextIndex(int) -> h
    int previousIndex(int) -> i
    void triangulate() -> j
com.badlogic.gdx.math.Ellipse -> c0.c:
    float height -> d
    float width -> c
    float y -> b
    float x -> a
com.badlogic.gdx.math.Frustum -> c0.d:
    com.badlogic.gdx.math.Vector3[] planePoints -> b
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> d
    float[] clipSpacePlanePointsArray -> e
    float[] planePointsArray -> c
    com.badlogic.gdx.math.Plane[] planes -> a
    com.badlogic.gdx.math.Vector3 tmpV -> f
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.GeometryUtils -> c0.e:
    com.badlogic.gdx.math.Vector2 tmp3 -> c
    com.badlogic.gdx.math.Vector2 tmp1 -> a
    com.badlogic.gdx.math.Vector2 tmp2 -> b
    boolean isClockwise(float[],int,int) -> a
com.badlogic.gdx.math.Interpolation -> c0.f:
    com.badlogic.gdx.math.Interpolation$PowIn pow5In -> v
    com.badlogic.gdx.math.Interpolation$Pow pow2 -> f
    com.badlogic.gdx.math.Interpolation$ExpOut exp10Out -> C
    com.badlogic.gdx.math.Interpolation sineIn -> y
    com.badlogic.gdx.math.Interpolation$SwingOut swingOut -> O
    com.badlogic.gdx.math.Interpolation pow2InInverse -> k
    com.badlogic.gdx.math.Interpolation$Swing swing -> M
    com.badlogic.gdx.math.Interpolation pow3OutInverse -> q
    com.badlogic.gdx.math.Interpolation$PowOut pow4Out -> t
    com.badlogic.gdx.math.Interpolation$Elastic elastic -> J
    com.badlogic.gdx.math.Interpolation$ElasticOut elasticOut -> L
    com.badlogic.gdx.math.Interpolation fade -> e
    com.badlogic.gdx.math.Interpolation smooth2 -> c
    com.badlogic.gdx.math.Interpolation$ExpIn exp10In -> B
    com.badlogic.gdx.math.Interpolation$PowOut fastSlow -> j
    com.badlogic.gdx.math.Interpolation circleIn -> H
    com.badlogic.gdx.math.Interpolation$BounceOut bounceOut -> R
    com.badlogic.gdx.math.Interpolation$Exp exp10 -> A
    com.badlogic.gdx.math.Interpolation$PowIn pow2In -> g
    com.badlogic.gdx.math.Interpolation sineOut -> z
    com.badlogic.gdx.math.Interpolation$Pow pow5 -> u
    com.badlogic.gdx.math.Interpolation linear -> a
    com.badlogic.gdx.math.Interpolation$ElasticIn elasticIn -> K
    com.badlogic.gdx.math.Interpolation$PowIn pow4In -> s
    com.badlogic.gdx.math.Interpolation$Pow pow3 -> m
    com.badlogic.gdx.math.Interpolation sine -> x
    com.badlogic.gdx.math.Interpolation pow2OutInverse -> l
    com.badlogic.gdx.math.Interpolation$PowOut pow5Out -> w
    com.badlogic.gdx.math.Interpolation$Exp exp5 -> D
    com.badlogic.gdx.math.Interpolation pow3InInverse -> p
    com.badlogic.gdx.math.Interpolation$ExpOut exp5Out -> F
    com.badlogic.gdx.math.Interpolation smoother -> d
    com.badlogic.gdx.math.Interpolation$SwingIn swingIn -> N
    com.badlogic.gdx.math.Interpolation$PowOut pow3Out -> o
    com.badlogic.gdx.math.Interpolation smooth -> b
    com.badlogic.gdx.math.Interpolation$ExpIn exp5In -> E
    com.badlogic.gdx.math.Interpolation circleOut -> I
    com.badlogic.gdx.math.Interpolation$PowIn slowFast -> h
    com.badlogic.gdx.math.Interpolation circle -> G
    com.badlogic.gdx.math.Interpolation$PowIn pow3In -> n
    com.badlogic.gdx.math.Interpolation$PowOut pow2Out -> i
    com.badlogic.gdx.math.Interpolation$BounceIn bounceIn -> Q
    com.badlogic.gdx.math.Interpolation$Bounce bounce -> P
    com.badlogic.gdx.math.Interpolation$Pow pow4 -> r
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$1 -> c0.f$f:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$10 -> c0.f$a:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$11 -> c0.f$b:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$12 -> c0.f$c:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$13 -> c0.f$d:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$14 -> c0.f$e:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$2 -> c0.f$g:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$3 -> c0.f$h:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$4 -> c0.f$i:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$5 -> c0.f$j:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$6 -> c0.f$k:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$7 -> c0.f$l:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$8 -> c0.f$m:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$9 -> c0.f$n:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Bounce -> c0.f$o:
    float apply(float) -> a
    float out(float) -> b
com.badlogic.gdx.math.Interpolation$BounceIn -> c0.f$p:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$BounceOut -> c0.f$q:
    float[] widths -> S
    float[] heights -> T
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Elastic -> c0.f$r:
    float bounces -> V
    float scale -> U
    float power -> T
    float value -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticIn -> c0.f$s:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ElasticOut -> c0.f$t:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Exp -> c0.f$u:
    float scale -> V
    float min -> U
    float power -> T
    float value -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpIn -> c0.f$v:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$ExpOut -> c0.f$w:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Pow -> c0.f$x:
    int power -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowIn -> c0.f$y:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$PowOut -> c0.f$z:
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$Swing -> c0.f$a0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingIn -> c0.f$b0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.Interpolation$SwingOut -> c0.f$c0:
    float scale -> S
    float apply(float) -> a
com.badlogic.gdx.math.MathUtils -> c0.g:
    java.util.Random random -> a
    float clamp(float,float,float) -> a
    int clamp(int,int,int) -> b
    float cos(float) -> c
    float cosDeg(float) -> d
    boolean isEqual(float,float) -> e
    boolean isEqual(float,float,float) -> f
    boolean isPowerOfTwo(int) -> g
    float map(float,float,float,float,float) -> h
    int nextPowerOfTwo(int) -> i
    float random() -> j
    float random(float,float) -> k
    int random(int) -> l
    int random(int,int) -> m
    boolean randomBoolean() -> n
    boolean randomBoolean(float) -> o
    int roundPositive(float) -> p
    float sin(float) -> q
    float sinDeg(float) -> r
com.badlogic.gdx.math.MathUtils$Sin -> c0.g$a:
    float[] table -> a
com.badlogic.gdx.math.Matrix3 -> c0.h:
    float[] val -> a
    float[] tmp -> b
    com.badlogic.gdx.math.Matrix3 idt() -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    com.badlogic.gdx.math.Vector3 l_vez -> d
    com.badlogic.gdx.math.Vector3 l_vex -> e
    com.badlogic.gdx.math.Quaternion quat2 -> c
    com.badlogic.gdx.math.Quaternion quat -> b
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    com.badlogic.gdx.math.Vector3 tmpForward -> j
    com.badlogic.gdx.math.Vector3 tmpUp -> k
    float[] val -> a
    com.badlogic.gdx.math.Vector3 right -> i
    com.badlogic.gdx.math.Vector3 l_vey -> f
    com.badlogic.gdx.math.Vector3 tmpVec -> g
    float det(float[]) -> a
    com.badlogic.gdx.math.Matrix4 idt() -> b
    com.badlogic.gdx.math.Matrix4 inv() -> c
    boolean inv(float[]) -> d
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> e
    void mul(float[],float[]) -> f
    com.badlogic.gdx.math.Matrix4 rotate(com.badlogic.gdx.math.Quaternion) -> g
    com.badlogic.gdx.math.Matrix4 scale(float,float,float) -> h
    com.badlogic.gdx.math.Matrix4 set(float,float,float,float,float,float,float,float,float,float) -> i
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Affine2) -> j
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Quaternion,com.badlogic.gdx.math.Vector3) -> k
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> l
    com.badlogic.gdx.math.Matrix4 set(float[]) -> m
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> n
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> o
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> p
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> q
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> r
    com.badlogic.gdx.math.Matrix4 translate(float,float,float) -> s
com.badlogic.gdx.math.Plane -> c0.i:
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
com.badlogic.gdx.math.Polygon -> c0.j:
    float scaleY -> e
    float scaleX -> d
    float y -> c
    boolean dirty -> f
    float x -> b
    float[] localVertices -> a
    void setPosition(float,float) -> a
com.badlogic.gdx.math.Polyline -> c0.k:
    float scaleY -> e
    float scaleX -> d
    float y -> c
    boolean calculateScaledLength -> f
    float x -> b
    boolean calculateLength -> g
    boolean dirty -> h
    float[] localVertices -> a
    void setPosition(float,float) -> a
com.badlogic.gdx.math.Quaternion -> c0.l:
    com.badlogic.gdx.math.Quaternion tmp2 -> f
    com.badlogic.gdx.math.Quaternion tmp1 -> e
    float w -> d
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Quaternion idt() -> a
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> b
    com.badlogic.gdx.math.Quaternion set(com.badlogic.gdx.math.Quaternion) -> c
com.badlogic.gdx.math.RandomXS128 -> c0.m:
    long seed1 -> b
    long seed0 -> a
    long murmurHash3(long) -> a
    long nextLong(long) -> b
    void setState(long,long) -> c
com.badlogic.gdx.math.Rectangle -> c0.n:
    com.badlogic.gdx.math.Rectangle tmp2 -> f
    com.badlogic.gdx.math.Rectangle tmp -> e
    float height -> d
    float width -> c
    float y -> b
    float x -> a
    float getHeight() -> a
    float getWidth() -> b
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> c
com.badlogic.gdx.math.Vector2 -> c0.o:
    com.badlogic.gdx.math.Vector2 X -> c
    com.badlogic.gdx.math.Vector2 Y -> d
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector2 Zero -> e
    com.badlogic.gdx.math.Vector2 add(com.badlogic.gdx.math.Vector2) -> a
    float angleDeg() -> b
    float angleDeg(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 clamp(float,float) -> d
    com.badlogic.gdx.math.Vector2 cpy() -> e
    float crs(com.badlogic.gdx.math.Vector2) -> f
    float dot(com.badlogic.gdx.math.Vector2) -> g
    float dst2(float,float) -> h
    float dst2(float,float,float,float) -> i
    float dst2(com.badlogic.gdx.math.Vector2) -> j
    float len() -> k
    float len2() -> l
    com.badlogic.gdx.math.Vector2 nor() -> m
    com.badlogic.gdx.math.Vector2 rotateDeg(float) -> n
    com.badlogic.gdx.math.Vector2 rotateRad(float) -> o
    com.badlogic.gdx.math.Vector2 scl(float) -> p
    com.badlogic.gdx.math.Vector2 set(float,float) -> q
    com.badlogic.gdx.math.Vector2 set(com.badlogic.gdx.math.Vector2) -> r
    com.badlogic.gdx.math.Vector2 setAngleDeg(float) -> s
    com.badlogic.gdx.math.Vector2 setAngleRad(float) -> t
    com.badlogic.gdx.math.Vector2 setLength(float) -> u
    com.badlogic.gdx.math.Vector2 setLength2(float) -> v
    com.badlogic.gdx.math.Vector2 setToRandomDirection() -> w
    com.badlogic.gdx.math.Vector2 setZero() -> x
    com.badlogic.gdx.math.Vector2 sub(float,float) -> y
    com.badlogic.gdx.math.Vector2 sub(com.badlogic.gdx.math.Vector2) -> z
com.badlogic.gdx.math.Vector3 -> c0.p:
    com.badlogic.gdx.math.Vector3 X -> d
    com.badlogic.gdx.math.Vector3 Y -> e
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector3 Z -> f
    com.badlogic.gdx.math.Vector3 Zero -> g
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 cpy() -> c
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> d
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> e
    float dot(com.badlogic.gdx.math.Vector3) -> f
    float len() -> g
    float len2() -> h
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> i
    com.badlogic.gdx.math.Vector3 nor() -> j
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> k
    com.badlogic.gdx.math.Vector3 scl(float) -> l
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> m
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> n
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> o
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> p
com.badlogic.gdx.math.collision.BoundingBox -> d0.a:
    com.badlogic.gdx.math.Vector3 dim -> d
    com.badlogic.gdx.math.Vector3 tmpVector -> e
    com.badlogic.gdx.math.Vector3 max -> b
    com.badlogic.gdx.math.Vector3 cnt -> c
    com.badlogic.gdx.math.Vector3 min -> a
    com.badlogic.gdx.math.collision.BoundingBox clr() -> a
    com.badlogic.gdx.math.collision.BoundingBox ext(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 getCenter(com.badlogic.gdx.math.Vector3) -> c
    com.badlogic.gdx.math.Vector3 getDimensions(com.badlogic.gdx.math.Vector3) -> d
    com.badlogic.gdx.math.collision.BoundingBox inf() -> e
    float min(float,float) -> f
    com.badlogic.gdx.math.collision.BoundingBox set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> g
    void update() -> h
com.badlogic.gdx.math.collision.Ray -> d0.b:
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 tmp -> c
    com.badlogic.gdx.math.Vector3 origin -> a
com.badlogic.gdx.net.NetJavaImpl -> e0.a:
    java.util.concurrent.ThreadPoolExecutor executorService -> a
    com.badlogic.gdx.utils.ObjectMap tasks -> d
    com.badlogic.gdx.utils.ObjectMap listeners -> c
    com.badlogic.gdx.utils.ObjectMap connections -> b
com.badlogic.gdx.net.NetJavaImpl$1 -> e0.a$a:
    java.util.concurrent.atomic.AtomicInteger threadID -> a
    com.badlogic.gdx.net.NetJavaImpl this$0 -> b
com.badlogic.gdx.scenes.scene2d.Action -> f0.a:
    com.badlogic.gdx.utils.Pool pool -> c
    com.badlogic.gdx.scenes.scene2d.Actor target -> b
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    void restart() -> a
    void reset() -> b
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> c
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> d
com.badlogic.gdx.scenes.scene2d.Actor -> f0.b:
    float width -> l
    java.lang.String name -> f
    float y -> k
    float x -> j
    boolean debug -> i
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> g
    com.badlogic.gdx.scenes.scene2d.Group parent -> b
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> c
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> d
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.utils.Array actions -> e
    float rotation -> r
    boolean visible -> h
    float scaleY -> q
    float scaleX -> p
    float originY -> o
    float originX -> n
    com.badlogic.gdx.graphics.Color color -> s
    float height -> m
    float getRotation() -> A
    float getScaleX() -> B
    float getScaleY() -> C
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> D
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> E
    float getWidth() -> F
    float getX() -> G
    float getY() -> H
    boolean hasKeyboardFocus() -> I
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> J
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> K
    boolean isVisible() -> L
    com.badlogic.gdx.math.Vector2 localToAscendantCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> M
    com.badlogic.gdx.math.Vector2 localToParentCoordinates(com.badlogic.gdx.math.Vector2) -> N
    com.badlogic.gdx.math.Vector2 localToStageCoordinates(com.badlogic.gdx.math.Vector2) -> O
    void moveBy(float,float) -> P
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> Q
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> R
    void positionChanged() -> S
    boolean remove() -> T
    void setBounds(float,float,float,float) -> U
    void setColor(float,float,float,float) -> V
    void setColor(com.badlogic.gdx.graphics.Color) -> W
    void setDebug(boolean) -> X
    void setHeight(float) -> Y
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> Z
    void setPosition(float,float) -> a0
    void setSize(float,float) -> b0
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> c0
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> d0
    void setVisible(boolean) -> e0
    void setWidth(float) -> f0
    void setX(float) -> g0
    void setY(float) -> h0
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> i
    void sizeChanged() -> i0
    boolean ascendantsVisible() -> j
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> j0
    void clear() -> k
    void clearActions() -> l
    void clearListeners() -> m
    boolean clipBegin(float,float,float,float) -> n
    void clipEnd() -> o
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> q
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> r
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> s
    com.badlogic.gdx.graphics.Color getColor() -> t
    boolean getDebug() -> u
    float getHeight() -> v
    java.lang.String getName() -> w
    float getOriginX() -> x
    float getOriginY() -> y
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> z
com.badlogic.gdx.scenes.scene2d.Event -> f0.c:
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    boolean capture -> d
    boolean getBubbles() -> a
    void reset() -> b
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> c
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> d
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> e
    void handle() -> f
    boolean isCancelled() -> g
    boolean isHandled() -> h
    boolean isStopped() -> i
    void setCapture(boolean) -> j
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> k
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> l
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> m
com.badlogic.gdx.scenes.scene2d.EventListener -> f0.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> f0.e:
    com.badlogic.gdx.utils.SnapshotArray children -> t
    com.badlogic.gdx.math.Matrix4 oldTransform -> w
    com.badlogic.gdx.math.Rectangle cullingArea -> y
    com.badlogic.gdx.math.Matrix4 computedTransform -> v
    com.badlogic.gdx.math.Affine2 worldTransform -> u
    boolean transform -> x
    com.badlogic.gdx.math.Vector2 tmp -> z
    void setTransform(boolean) -> A0
    void toString(java.lang.StringBuilder,int) -> B0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> J
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> c0
    void clear() -> k
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> k0
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> l0
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> m0
    void childrenChanged() -> n0
    void clearChildren(boolean) -> o0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    com.badlogic.gdx.math.Matrix4 computeTransform() -> p0
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> q
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> q0
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> r0
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> s0
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> t0
    boolean isTransform() -> u0
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> v0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> w0
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> x0
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> y0
    void setDebug(boolean,boolean) -> z0
com.badlogic.gdx.scenes.scene2d.InputEvent -> f0.f:
    float scrollAmountX -> l
    int pointer -> n
    float stageY -> k
    int button -> o
    float stageX -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> r
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> i
    char character -> q
    int keyCode -> p
    boolean touchFocus -> s
    float scrollAmountY -> m
    void setScrollAmountX(float) -> A
    void setScrollAmountY(float) -> B
    void setStageX(float) -> C
    void setStageY(float) -> D
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> E
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> F
    void reset() -> b
    int getButton() -> n
    char getCharacter() -> o
    int getKeyCode() -> p
    int getPointer() -> q
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> r
    float getScrollAmountX() -> s
    float getScrollAmountY() -> t
    boolean getTouchFocus() -> u
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> v
    void setButton(int) -> w
    void setCharacter(char) -> x
    void setKeyCode(int) -> y
    void setPointer(int) -> z
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> f0.f$a:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
com.badlogic.gdx.scenes.scene2d.InputListener -> f0.g:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> f
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> h
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> f0.g$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> f0.h:
    boolean actionsRequestRendering -> o
    int mouseScreenX -> j
    int mouseScreenY -> k
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> p
    com.badlogic.gdx.graphics.g2d.Batch batch -> b
    boolean debug -> v
    boolean debugAll -> q
    boolean debugUnderMouse -> r
    com.badlogic.gdx.math.Vector2 tempCoords -> e
    boolean debugParentUnderMouse -> s
    com.badlogic.gdx.scenes.scene2d.Group root -> d
    com.badlogic.gdx.graphics.Color debugColor -> u
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> f
    boolean[] pointerTouched -> g
    int[] pointerScreenX -> h
    int[] pointerScreenY -> i
    com.badlogic.gdx.utils.viewport.Viewport viewport -> a
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> n
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> m
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> l
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> t
    boolean ownsBatch -> c
    boolean mouseMoved(int,int) -> A
    boolean touchUp(int,int,int,int) -> E
    boolean scrolled(float,float) -> G
    boolean touchDragged(int,int,int) -> Q
    boolean keyUp(int) -> W
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> X
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> Y
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> Z
    void dispose() -> a
    void cancelTouchFocus() -> a0
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> b0
    void cancelTouchFocusExcept(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor) -> c0
    void clear() -> d0
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> e0
    void draw() -> f0
    void drawDebug() -> g0
    boolean getActionsRequestRendering() -> h0
    com.badlogic.gdx.utils.Array getActors() -> i0
    com.badlogic.gdx.graphics.Color getDebugColor() -> j0
    boolean keyTyped(char) -> k
    float getHeight() -> k0
    com.badlogic.gdx.scenes.scene2d.Actor getKeyboardFocus() -> l0
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> m0
    float getWidth() -> n0
    boolean keyDown(int) -> o
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> o0
    boolean touchDown(int,int,int,int) -> p
    boolean isInsideViewport(int,int) -> p0
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> q0
    boolean setKeyboardFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> r0
    boolean setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> s0
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> t0
    void unfocusAll() -> u0
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> f0.h$a:
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    int pointer -> d
    int button -> e
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    void reset() -> b
com.badlogic.gdx.scenes.scene2d.Touchable -> f0.i:
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
com.badlogic.gdx.scenes.scene2d.ui.Button -> g0.a:
    boolean isDisabled -> u0
    boolean isChecked -> t0
    boolean programmaticChangeEvents -> w0
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> v0
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> s0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> X0
    void initialize() -> Y0
    boolean isChecked() -> Z0
    float getMinHeight() -> a
    boolean isDisabled() -> a1
    float getMinWidth() -> b
    boolean isOver() -> b1
    boolean isPressed() -> c1
    void setChecked(boolean,boolean) -> d1
    float getPrefWidth() -> e
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> e1
    float getPrefHeight() -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> g0.a$a:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> g0.a$b:
    float unpressedOffsetX -> l
    float pressedOffsetY -> k
    float pressedOffsetX -> j
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focused -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedDown -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedFocused -> i
    float checkedOffsetY -> o
    float checkedOffsetX -> n
    float unpressedOffsetY -> m
com.badlogic.gdx.scenes.scene2d.ui.Cell -> g0.b:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    float computedPadRight -> J
    float computedPadLeft -> H
    int row -> E
    com.badlogic.gdx.Files files -> T
    java.lang.Integer righti -> S
    java.lang.Float fillY -> p
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformY -> v
    float actorY -> y
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    java.lang.Float zerof -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> B
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    java.lang.Integer zeroi -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    java.lang.Integer centeri -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults -> U
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    boolean endRow -> C
    java.lang.Integer bottomi -> Q
    java.lang.Integer expandX -> r
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    float computedPadBottom -> I
    float computedPadTop -> G
    int cellAboveIndex -> F
    int column -> D
    float actorHeight -> A
    java.lang.Float fillX -> o
    java.lang.Integer expandY -> s
    java.lang.Boolean uniformX -> u
    float actorWidth -> z
    float actorX -> x
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    java.lang.Float onef -> L
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    java.lang.Integer onei -> N
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    java.lang.Integer topi -> P
    java.lang.Integer align -> q
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    java.lang.Integer lefti -> R
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> a
    void reset() -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> d
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> e
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> f
    void setTable(com.badlogic.gdx.scenes.scene2d.ui.Table) -> g
com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle -> g0.c:
com.badlogic.gdx.scenes.scene2d.ui.Image -> g0.d:
    com.badlogic.gdx.utils.Scaling scaling -> w
    float imageY -> z
    float imageX -> y
    int align -> x
    float imageHeight -> B
    float imageWidth -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> C
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getPrefWidth() -> e
    float getPrefHeight() -> h
    void layout() -> l0
    float getImageHeight() -> m0
    float getImageWidth() -> n0
    float getImageX() -> o0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    float getImageY() -> p0
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> q0
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle -> g0.e:
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle -> g0.f:
com.badlogic.gdx.scenes.scene2d.ui.Label -> g0.g:
    float fontScaleY -> J
    float fontScaleX -> I
    float lastPrefHeight -> G
    boolean fontScaleChanged -> K
    java.lang.String ellipsis -> L
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> w
    int labelAlign -> D
    int lineAlign -> E
    int intValue -> B
    float prefHeight -> z
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> x
    float prefWidth -> y
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> C
    com.badlogic.gdx.utils.StringBuilder text -> A
    com.badlogic.gdx.graphics.Color tempColor -> M
    boolean wrap -> F
    com.badlogic.gdx.graphics.g2d.GlyphLayout prefSizeLayout -> N
    boolean prefSizeInvalid -> H
    float getPrefWidth() -> e
    float getPrefHeight() -> h
    void invalidate() -> k0
    void layout() -> l0
    void computePrefSize(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> m0
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> n0
    com.badlogic.gdx.utils.StringBuilder getText() -> o0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    void scaleAndComputePrefSize() -> p0
    void setAlignment(int) -> q0
    void setAlignment(int,int) -> r0
    void setFontScale(float) -> s0
    void setFontScale(float,float) -> t0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> u0
    void setText(java.lang.CharSequence) -> v0
    boolean setText(int) -> w0
    boolean textEquals(java.lang.CharSequence) -> x0
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> g0.g$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle -> g0.h:
    com.badlogic.gdx.graphics.Color fontColorSelected -> a
    com.badlogic.gdx.graphics.Color fontColorUnselected -> b
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle -> g0.i:
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> g0.j:
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle -> g0.k:
    com.badlogic.gdx.graphics.Color fontColor -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin -> g0.l:
    java.lang.Class[] defaultTagClasses -> e
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    float scale -> c
    com.badlogic.gdx.utils.ObjectMap jsonClassTags -> d
    java.lang.Object get(java.lang.Class) -> A
    java.lang.Object get(java.lang.String,java.lang.Class) -> E
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> G
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> Q
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> W
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> X
    com.badlogic.gdx.utils.Array getRegions(java.lang.String) -> Y
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> Z
    void dispose() -> a
    void load(com.badlogic.gdx.files.FileHandle) -> a0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> b0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> c0
    java.lang.Object optional(java.lang.String,java.lang.Class) -> d0
    void scale(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> e0
    void add(java.lang.String,java.lang.Object) -> k
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> o
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> p
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> g0.l$a:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> q
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> g0.l$b:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> c
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> g0.l$c:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> g0.l$d:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> g0.l$e:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> g0.l$f:
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle -> g0.m:
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle -> g0.n:
com.badlogic.gdx.scenes.scene2d.ui.Table -> g0.o:
    float[] rowMinHeight -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundLeft -> p0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundTop -> o0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundRight -> r0
    boolean clip -> f0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundBottom -> q0
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> Y
    int rows -> E
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> g0
    float[] expandHeight -> W
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> a0
    float[] rowHeight -> U
    float tablePrefWidth -> R
    com.badlogic.gdx.utils.Array columnDefaults -> I
    float tableMinWidth -> P
    com.badlogic.gdx.utils.Array cells -> G
    float[] rowPrefHeight -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> J
    float[] columnPrefWidth -> N
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> c0
    int align -> b0
    float[] columnMinWidth -> L
    com.badlogic.gdx.utils.Pool cellPool -> l0
    boolean sizeInvalid -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> X
    float[] columnWeightedWidth -> m0
    int columns -> D
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> Z
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e0
    com.badlogic.gdx.graphics.Color debugTableColor -> i0
    com.badlogic.gdx.graphics.Color debugCellColor -> j0
    com.badlogic.gdx.graphics.Color debugActorColor -> k0
    float[] rowWeightedHeight -> n0
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> H
    com.badlogic.gdx.utils.Array debugRects -> d0
    boolean implicitEndRow -> F
    float tablePrefHeight -> S
    float[] expandWidth -> V
    float tableMinHeight -> Q
    float[] columnWidth -> T
    boolean round -> h0
    void invalidate() -> C0
    void layout() -> D0
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> E0
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> F0
    void addDebugRects(float,float,float,float) -> G0
    void clearDebugRects() -> H0
    void computeSize() -> I0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> J
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> J0
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> K0
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> L0
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> M0
    void endRow() -> N0
    float[] ensureSize(float[],int) -> O0
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> P0
    float getPadBottom() -> Q0
    float getPadLeft() -> R0
    float getPadRight() -> S0
    float getPadTop() -> T0
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> U0
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> V0
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> W0
    void setDebug(boolean) -> X
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getPrefWidth() -> e
    float getPrefHeight() -> h
    void clearChildren(boolean) -> o0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> q
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> q0
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> r
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> v0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> w0
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> g0.o$a:
    java.lang.Object newObject() -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> g
com.badlogic.gdx.scenes.scene2d.ui.Table$2 -> g0.o$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$3 -> g0.o$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$4 -> g0.o$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$5 -> g0.o$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> g0.o$f:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> b
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> g0.o$g:
    com.badlogic.gdx.graphics.Color color -> g
    com.badlogic.gdx.utils.Pool pool -> h
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> g0.p:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> x0
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> y0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> e1
    com.badlogic.gdx.graphics.Color getFontColor() -> f1
    com.badlogic.gdx.scenes.scene2d.ui.Label newLabel(java.lang.String,com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> g1
    void setText(java.lang.String) -> h1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> g0.p$a:
    com.badlogic.gdx.graphics.Color disabledFontColor -> u
    com.badlogic.gdx.graphics.Color focusedFontColor -> t
    com.badlogic.gdx.graphics.Color checkedDownFontColor -> w
    com.badlogic.gdx.graphics.Color checkedFontColor -> v
    com.badlogic.gdx.graphics.Color checkedFocusedFontColor -> y
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> x
    com.badlogic.gdx.graphics.Color fontColor -> q
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> p
    com.badlogic.gdx.graphics.Color overFontColor -> s
    com.badlogic.gdx.graphics.Color downFontColor -> r
com.badlogic.gdx.scenes.scene2d.ui.TextField -> g0.q:
    boolean focused -> d0
    boolean disabled -> N
    int textHAlign -> O
    boolean cursorOn -> e0
    float blinkTime -> f0
    boolean focusTraversal -> L
    float keyRepeatInitialTime -> m0
    com.badlogic.gdx.utils.Timer$Task blinkTask -> g0
    float keyRepeatTime -> n0
    java.lang.StringBuilder passwordBuffer -> U
    boolean passwordMode -> T
    com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard keyboard -> K
    float renderOffset -> Z
    com.badlogic.gdx.math.Vector2 tmp3 -> l0
    float textHeight -> X
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener listener -> I
    int selectionStart -> y
    boolean writeEnters -> A
    float selectionX -> P
    boolean onlyFontChars -> M
    int maxLength -> c0
    int visibleTextEnd -> b0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter filter -> J
    int visibleTextStart -> a0
    com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask keyRepeatTask -> h0
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> B
    java.lang.CharSequence displayText -> F
    com.badlogic.gdx.utils.FloatArray glyphPositions -> C
    com.badlogic.gdx.math.Vector2 tmp2 -> k0
    java.lang.String undoText -> R
    com.badlogic.gdx.math.Vector2 tmp1 -> j0
    char passwordCharacter -> V
    java.lang.String text -> w
    float textOffset -> Y
    boolean hasSelection -> z
    float fontOffset -> W
    int cursor -> x
    com.badlogic.gdx.utils.Clipboard clipboard -> G
    com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle style -> D
    com.badlogic.gdx.scenes.scene2d.InputListener inputListener -> H
    float selectionWidth -> Q
    long lastChangeTime -> S
    boolean programmaticChangeEvents -> i0
    java.lang.String messageText -> E
    java.lang.String getText() -> A0
    float getTextY(com.badlogic.gdx.graphics.g2d.BitmapFont,com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> B0
    void initialize() -> C0
    java.lang.String insert(int,java.lang.CharSequence,java.lang.String) -> D0
    boolean isDisabled() -> E0
    boolean isWordCharacter(char) -> F0
    int letterUnderCursor(float) -> G0
    void moveCursor(boolean,boolean) -> H0
    void next(boolean) -> I0
    void paste(java.lang.String,boolean) -> J0
    void selectAll() -> K0
    void setMaxLength(int) -> L0
    void setSelection(int,int) -> M0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle) -> N0
    void setText(java.lang.String) -> O0
    void updateDisplayText() -> P0
    boolean withinMaxLength(int) -> Q0
    int[] wordUnderCursor(float) -> R0
    int[] wordUnderCursor(int) -> S0
    float getPrefWidth() -> e
    float getPrefHeight() -> h
    void calculateOffsets() -> m0
    boolean changeText(java.lang.String,java.lang.String) -> n0
    void clearSelection() -> o0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    boolean continueCursor(int,int) -> p0
    void copy() -> q0
    com.badlogic.gdx.scenes.scene2d.InputListener createInputListener() -> r0
    void cut(boolean) -> s0
    int delete(boolean) -> t0
    void drawCursor(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> u0
    void drawMessageText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float,float) -> v0
    void drawSelection(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> w0
    void drawText(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.graphics.g2d.BitmapFont,float,float) -> x0
    com.badlogic.gdx.scenes.scene2d.ui.TextField findNextTextField(com.badlogic.gdx.utils.Array,com.badlogic.gdx.scenes.scene2d.ui.TextField,com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,boolean) -> y0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> z0
com.badlogic.gdx.scenes.scene2d.ui.TextField$1 -> g0.q$a:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> f
com.badlogic.gdx.scenes.scene2d.ui.TextField$DefaultOnscreenKeyboard -> g0.q$b:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$KeyRepeatTask -> g0.q$c:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> g
    int keycode -> f
com.badlogic.gdx.scenes.scene2d.ui.TextField$OnscreenKeyboard -> g0.q$d:
    void show(boolean) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldClickListener -> g0.q$e:
    com.badlogic.gdx.scenes.scene2d.ui.TextField this$0 -> p
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> f
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
    boolean checkFocusTraversal(char) -> u
    void goEnd(boolean) -> v
    void goHome(boolean) -> w
    void scheduleKeyRepeatTask(int) -> x
    void setCursorPosition(float,float) -> y
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldFilter -> g0.q$f:
    boolean acceptChar(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldListener -> g0.q$g:
    void keyTyped(com.badlogic.gdx.scenes.scene2d.ui.TextField,char) -> a
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle -> g0.q$h:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable cursor -> h
    com.badlogic.gdx.graphics.Color disabledFontColor -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable selection -> i
    com.badlogic.gdx.graphics.Color messageFontColor -> k
    com.badlogic.gdx.graphics.g2d.BitmapFont messageFont -> j
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e
    com.badlogic.gdx.graphics.Color focusedFontColor -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focusedBackground -> f
    com.badlogic.gdx.graphics.Color fontColor -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabledBackground -> g
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle -> g0.r:
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle -> g0.s:
com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle -> g0.t:
com.badlogic.gdx.scenes.scene2d.ui.Value -> g0.u:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> g0.u$a:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> g0.u$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> g0.u$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> g0.u$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> g0.u$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> g0.u$f:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> g0.u$g:
    float value -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed[] cache -> i
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Widget -> g0.v:
    boolean fillParent -> u
    boolean layoutEnabled -> v
    boolean needsLayout -> t
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getPrefWidth() -> e
    float getMaxWidth() -> f
    void validate() -> g
    float getPrefHeight() -> h
    void sizeChanged() -> i0
    void invalidate() -> k0
    void layout() -> l0
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> g0.w:
    boolean needsLayout -> A
    boolean fillParent -> B
    boolean layoutEnabled -> C
    void invalidate() -> C0
    void layout() -> D0
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getMaxWidth() -> f
    void validate() -> g
    void sizeChanged() -> i0
    void childrenChanged() -> n0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle -> g0.x:
    com.badlogic.gdx.graphics.Color titleFontColor -> a
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> h0.a:
    float minHeight -> g
    float minWidth -> f
    float bottomHeight -> e
    float topHeight -> d
    float rightWidth -> c
    java.lang.String name -> a
    float leftWidth -> b
    float getMinHeight() -> a
    float getMinWidth() -> b
    void setTopHeight(float) -> c
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void setMinHeight(float) -> e
    float getLeftWidth() -> f
    void setMinWidth(float) -> g
    float getRightWidth() -> i
    void setLeftWidth(float) -> j
    float getBottomHeight() -> k
    float getTopHeight() -> l
    void setRightWidth(float) -> m
    void setBottomHeight(float) -> n
    java.lang.String getName() -> o
    void setName(java.lang.String) -> p
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> h0.b:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> h0.c:
    long tapCountInterval -> l
    long visualPressedTime -> k
    int tapCount -> m
    boolean over -> i
    boolean cancelled -> j
    float touchDownY -> d
    int pressedButton -> f
    float touchDownX -> c
    int button -> g
    float tapSquareSize -> b
    int pressedPointer -> e
    boolean pressed -> h
    long lastTapTime -> n
    float visualPressedDuration -> o
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
    int getTapCount() -> m
    boolean inTapSquare(float,float) -> n
    void invalidateTapSquare() -> o
    boolean isOver() -> p
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> q
    boolean isPressed() -> r
    boolean isVisualPressed() -> s
    void setVisualPressed(boolean) -> t
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> h0.d:
    float getMinHeight() -> a
    float getMinWidth() -> b
    void setTopHeight(float) -> c
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void setMinHeight(float) -> e
    float getLeftWidth() -> f
    void setMinWidth(float) -> g
    float getRightWidth() -> i
    void setLeftWidth(float) -> j
    float getBottomHeight() -> k
    float getTopHeight() -> l
    void setRightWidth(float) -> m
    void setBottomHeight(float) -> n
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> h0.e:
    boolean focused -> i
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> k
    void reset() -> b
    void setFocused(boolean) -> n
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> o
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> p
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> h0.e$a:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> c
com.badlogic.gdx.scenes.scene2d.utils.Layout -> h0.f:
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getPrefWidth() -> e
    float getMaxWidth() -> f
    void validate() -> g
    float getPrefHeight() -> h
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> h0.g:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> h
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> q
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> r
    com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> h0.h:
    com.badlogic.gdx.math.Vector3 tmp -> b
    com.badlogic.gdx.utils.Array scissors -> a
    com.badlogic.gdx.math.Rectangle viewport -> c
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    com.badlogic.gdx.math.Rectangle popScissors() -> c
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> d
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> h0.i:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> h
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> q
    com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable tint(com.badlogic.gdx.graphics.Color) -> r
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> h0.j:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> h
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> q
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> r
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> h0.k:
    float scale -> j
    com.badlogic.gdx.graphics.Color color -> i
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
    com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable tint(com.badlogic.gdx.graphics.Color) -> t
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> h0.l:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> h
com.badlogic.gdx.scenes.scene2d.utils.UIUtils -> h0.m:
    boolean isIos -> e
    boolean isAndroid -> a
    boolean isMac -> b
    boolean isWindows -> c
    boolean isLinux -> d
    boolean ctrl() -> a
    boolean shift() -> b
com.badlogic.gdx.utils.Array -> i0.a:
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> d
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> b
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> c
    void addAll(java.lang.Object[],int,int) -> d
    void clear() -> e
    boolean contains(java.lang.Object,boolean) -> f
    java.lang.Object[] ensureCapacity(int) -> g
    java.lang.Object first() -> h
    java.lang.Object get(int) -> i
    int indexOf(java.lang.Object,boolean) -> j
    void insert(int,java.lang.Object) -> k
    boolean isEmpty() -> l
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> m
    java.lang.Object peek() -> n
    java.lang.Object pop() -> o
    java.lang.Object removeIndex(int) -> p
    void removeRange(int,int) -> q
    boolean removeValue(java.lang.Object,boolean) -> r
    java.lang.Object[] resize(int) -> s
    void set(int,java.lang.Object) -> t
    void sort() -> u
    void sort(java.util.Comparator) -> v
    java.lang.Object[] toArray(java.lang.Class) -> w
    void truncate(int) -> x
    com.badlogic.gdx.utils.Array with(java.lang.Object[]) -> y
com.badlogic.gdx.utils.Array$ArrayIterable -> i0.a$a:
    com.badlogic.gdx.utils.Array array -> a
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> c
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.Array$ArrayIterator -> i0.a$b:
    com.badlogic.gdx.utils.Array array -> a
    boolean allowRemove -> b
    int index -> c
    boolean valid -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.ArrayMap -> i0.b:
    java.lang.Object[] values -> b
    java.lang.Object[] keys -> a
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    void clear() -> a
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> b
    java.lang.Object get(java.lang.Object) -> c
    java.lang.Object get(java.lang.Object,java.lang.Object) -> d
    int indexOfKey(java.lang.Object) -> e
    int put(java.lang.Object,java.lang.Object) -> f
    void removeIndex(int) -> g
    void resize(int) -> h
com.badlogic.gdx.utils.ArrayMap$Entries -> i0.b$a:
    com.badlogic.gdx.utils.ArrayMap map -> a
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> b
    int index -> c
    boolean valid -> d
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
com.badlogic.gdx.utils.Base64Coder -> i0.c:
    com.badlogic.gdx.utils.Base64Coder$CharMap regularMap -> a
    com.badlogic.gdx.utils.Base64Coder$CharMap urlsafeMap -> b
    byte[] decode(java.lang.String) -> a
    byte[] decode(char[]) -> b
    byte[] decode(char[],int,int,byte[]) -> c
com.badlogic.gdx.utils.Base64Coder$CharMap -> i0.c$a:
    char[] encodingMap -> a
    byte[] decodingMap -> b
com.badlogic.gdx.utils.BaseJsonReader -> i0.d:
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> b
    java.nio.ByteBuffer newByteBuffer(int) -> c
    java.nio.FloatBuffer newFloatBuffer(int) -> d
    java.nio.IntBuffer newIntBuffer(int) -> e
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> f
com.badlogic.gdx.utils.Clipboard -> i0.e:
    void setContents(java.lang.String) -> a
    java.lang.String getContents() -> b
com.badlogic.gdx.utils.Collections -> i0.f:
    boolean allocateIterators -> a
com.badlogic.gdx.utils.ComparableTimSort -> i0.g:
    int[] runBase -> f
    int[] runLen -> g
    java.lang.Object[] tmp -> c
    int tmpCount -> d
    int stackSize -> e
    int minGallop -> b
    void binarySort(java.lang.Object[],int,int,int) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int) -> b
    void doSort(java.lang.Object[],int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int) -> e
    int gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.DelayedRemovalArray -> i0.h:
    com.badlogic.gdx.utils.IntArray remove -> f
    int clear -> g
    int iterating -> e
    void end() -> A
    void remove(int) -> B
    void clear() -> e
    void insert(int,java.lang.Object) -> k
    java.lang.Object pop() -> o
    java.lang.Object removeIndex(int) -> p
    void removeRange(int,int) -> q
    boolean removeValue(java.lang.Object,boolean) -> r
    void set(int,java.lang.Object) -> t
    void sort() -> u
    void sort(java.util.Comparator) -> v
    void truncate(int) -> x
    void begin() -> z
com.badlogic.gdx.utils.Disposable -> i0.i:
    void dispose() -> a
com.badlogic.gdx.utils.FloatArray -> i0.j:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray) -> b
    void addAll(com.badlogic.gdx.utils.FloatArray,int,int) -> c
    void addAll(float[],int,int) -> d
    void clear() -> e
    float[] ensureCapacity(int) -> f
    float first() -> g
    float get(int) -> h
    boolean notEmpty() -> i
    void removeRange(int,int) -> j
    float[] resize(int) -> k
    void truncate(int) -> l
com.badlogic.gdx.utils.GdxNativesLoader -> i0.k:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> i0.l:
com.badlogic.gdx.utils.I18NBundle -> i0.m:
    com.badlogic.gdx.utils.TextFormatter formatter -> d
    java.util.Locale locale -> b
    com.badlogic.gdx.utils.I18NBundle parent -> a
    java.util.Locale ROOT_LOCALE -> e
    boolean simpleFormatter -> f
    boolean exceptionOnMissingKey -> g
    com.badlogic.gdx.utils.ObjectMap properties -> c
    boolean checkFileExistence(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> b
    com.badlogic.gdx.utils.I18NBundle createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> c
    com.badlogic.gdx.utils.I18NBundle createBundleImpl(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String) -> d
    java.util.List getCandidateLocales(java.util.Locale) -> e
    java.util.Locale getFallbackLocale(java.util.Locale) -> f
    java.util.Locale getLocale() -> g
    void load(java.io.Reader) -> h
    com.badlogic.gdx.utils.I18NBundle loadBundle(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.Locale) -> i
    com.badlogic.gdx.utils.I18NBundle loadBundleChain(com.badlogic.gdx.files.FileHandle,java.lang.String,java.util.List,int,com.badlogic.gdx.utils.I18NBundle) -> j
    void setLocale(java.util.Locale) -> k
    com.badlogic.gdx.files.FileHandle toFileHandle(com.badlogic.gdx.files.FileHandle,java.util.Locale) -> l
com.badlogic.gdx.utils.IntArray -> i0.n:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    void add(int,int) -> b
    void addAll(int[]) -> c
    void addAll(int[],int,int) -> d
    void clear() -> e
    int[] ensureCapacity(int) -> f
    int get(int) -> g
    void insert(int,int) -> h
    int peek() -> i
    int pop() -> j
    int removeIndex(int) -> k
    int[] resize(int) -> l
    void set(int,int) -> m
    int[] toArray() -> n
com.badlogic.gdx.utils.IntMap -> i0.o:
    java.lang.Object[] valueTable -> c
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    int mask -> i
    com.badlogic.gdx.utils.IntMap$Values values1 -> l
    int threshold -> g
    com.badlogic.gdx.utils.IntMap$Values values2 -> m
    int size -> a
    int[] keyTable -> b
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> j
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> k
    boolean hasZeroValue -> e
    com.badlogic.gdx.utils.IntMap$Entries entries() -> a
    java.lang.Object get(int) -> b
    java.lang.Object get(int,java.lang.Object) -> c
    int locateKey(int) -> d
    int place(int) -> e
    java.lang.Object put(int,java.lang.Object) -> f
    void putResize(int,java.lang.Object) -> g
    void resize(int) -> h
    com.badlogic.gdx.utils.IntMap$Values values() -> i
com.badlogic.gdx.utils.IntMap$Entries -> i0.o$a:
    com.badlogic.gdx.utils.IntMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.IntMap$Entry next() -> c
com.badlogic.gdx.utils.IntMap$Entry -> i0.o$b:
    java.lang.Object value -> b
    int key -> a
com.badlogic.gdx.utils.IntMap$MapIterator -> i0.o$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.IntMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntMap$Values -> i0.o$d:
    void reset() -> b
com.badlogic.gdx.utils.IntSet -> i0.p:
    int[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    boolean hasZeroValue -> c
    int size -> a
    boolean add(int) -> a
    void addResize(int) -> b
    boolean contains(int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    boolean remove(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.Json -> i0.q:
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> m
    com.badlogic.gdx.utils.ObjectMap classToTag -> l
    com.badlogic.gdx.utils.ObjectMap tagToClass -> k
    com.badlogic.gdx.utils.ObjectMap typeToFields -> j
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> n
    java.lang.Object[] equals2 -> p
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> c
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> i
    java.lang.Object[] equals1 -> o
    boolean ignoreDeprecated -> e
    boolean readDeprecated -> f
    java.lang.String typeName -> a
    boolean enumNames -> g
    boolean sortFields -> h
    boolean usePrototypes -> b
    boolean ignoreUnknownFields -> d
    void addClassTag(java.lang.String,java.lang.Class) -> a
    java.lang.String convertToString(java.lang.Enum) -> b
    void copyFields(java.lang.Object,java.lang.Object) -> c
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> d
    java.lang.Class getClass(java.lang.String) -> e
    com.badlogic.gdx.utils.OrderedMap getFields(java.lang.Class) -> f
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    java.lang.Object newInstance(java.lang.Class) -> h
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> j
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> k
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> l
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> m
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> n
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> o
    void setTypeName(java.lang.String) -> p
    void setUsePrototypes(boolean) -> q
    void sortFields(java.lang.Class,com.badlogic.gdx.utils.Array) -> r
com.badlogic.gdx.utils.Json$FieldMetadata -> i0.q$a:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
    boolean deprecated -> c
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> i0.q$b:
com.badlogic.gdx.utils.Json$Serializable -> i0.q$c:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> k
com.badlogic.gdx.utils.Json$Serializer -> i0.q$d:
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.utils.JsonReader -> i0.r:
    short[] _json_index_offsets -> j
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _json_trans_targs -> l
    byte[] _json_indicies -> k
    char[] _json_trans_keys -> g
    byte[] _json_eof_actions -> n
    byte[] _json_trans_actions -> m
    short[] _json_key_offsets -> f
    com.badlogic.gdx.utils.JsonValue current -> d
    byte[] _json_single_lengths -> h
    com.badlogic.gdx.utils.Array lastChild -> b
    com.badlogic.gdx.utils.JsonValue root -> c
    byte[] _json_range_lengths -> i
    byte[] _json_actions -> e
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> b
    void bool(java.lang.String,boolean) -> c
    byte[] init__json_actions_0() -> d
    byte[] init__json_eof_actions_0() -> e
    short[] init__json_index_offsets_0() -> f
    byte[] init__json_indicies_0() -> g
    short[] init__json_key_offsets_0() -> h
    byte[] init__json_range_lengths_0() -> i
    byte[] init__json_single_lengths_0() -> j
    byte[] init__json_trans_actions_0() -> k
    char[] init__json_trans_keys_0() -> l
    byte[] init__json_trans_targs_0() -> m
    void number(java.lang.String,double,java.lang.String) -> n
    void number(java.lang.String,long,java.lang.String) -> o
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> p
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> q
    void pop() -> r
    void startArray(java.lang.String) -> s
    void startObject(java.lang.String) -> t
    void string(java.lang.String,java.lang.String) -> u
    java.lang.String unescape(java.lang.String) -> v
com.badlogic.gdx.utils.JsonValue -> i0.s:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> a
    int size -> j
    double doubleValue -> c
    long longValue -> d
    com.badlogic.gdx.utils.JsonValue next -> h
    java.lang.String stringValue -> b
    com.badlogic.gdx.utils.JsonValue prev -> i
    java.lang.String name -> e
    com.badlogic.gdx.utils.JsonValue child -> f
    com.badlogic.gdx.utils.JsonValue parent -> g
    boolean isNumber() -> A
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> B
    boolean isObject() -> C
    boolean isString() -> D
    boolean isValue() -> E
    com.badlogic.gdx.utils.JsonValue$JsonIterator iterator() -> F
    java.lang.String name() -> G
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> H
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> I
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> J
    com.badlogic.gdx.utils.JsonValue require(java.lang.String) -> K
    void set(double,java.lang.String) -> L
    void set(long,java.lang.String) -> M
    void set(java.lang.String) -> N
    void set(boolean) -> O
    void setName(java.lang.String) -> P
    java.lang.String trace() -> Q
    boolean asBoolean() -> a
    byte asByte() -> b
    double asDouble() -> c
    float asFloat() -> d
    float[] asFloatArray() -> e
    int asInt() -> f
    long asLong() -> g
    short asShort() -> h
    short[] asShortArray() -> i
    java.lang.String asString() -> j
    com.badlogic.gdx.utils.JsonValue get(int) -> k
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> l
    com.badlogic.gdx.utils.JsonValue getChild(java.lang.String) -> m
    float getFloat(int) -> n
    float getFloat(java.lang.String,float) -> o
    short getShort(int) -> p
    java.lang.String getString(java.lang.String) -> q
    java.lang.String getString(java.lang.String,java.lang.String) -> r
    boolean has(java.lang.String) -> s
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> t
    boolean isArray() -> u
    boolean isBoolean() -> v
    boolean isDouble() -> w
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> x
    boolean isLong() -> y
    boolean isNull() -> z
com.badlogic.gdx.utils.JsonValue$1 -> i0.s$a:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> i0.s$b:
    com.badlogic.gdx.utils.JsonValue entry -> a
    com.badlogic.gdx.utils.JsonValue current -> b
    com.badlogic.gdx.utils.JsonValue this$0 -> c
    com.badlogic.gdx.utils.JsonValue next() -> a
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> i0.s$c:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> i0.s$d:
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
com.badlogic.gdx.utils.JsonWriter$1 -> i0.t:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> i0.u:
    java.util.regex.Pattern minimalValuePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    java.util.regex.Pattern minimalNamePattern -> e
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    java.lang.String quoteName(java.lang.String) -> a
    java.lang.String quoteValue(java.lang.Object) -> b
com.badlogic.gdx.utils.Logger -> i0.v:
    java.lang.String tag -> a
    int level -> b
    void debug(java.lang.String) -> a
    void error(java.lang.String) -> b
    void error(java.lang.String,java.lang.Throwable) -> c
    int getLevel() -> d
    void info(java.lang.String) -> e
com.badlogic.gdx.utils.LongMap -> i0.w:
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> k
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> j
    java.lang.Object[] valueTable -> c
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    long[] keyTable -> b
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    int size -> a
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
    java.lang.Object get(long) -> b
    java.lang.Object get(long,java.lang.Object) -> c
    int locateKey(long) -> d
    int place(long) -> e
    java.lang.Object put(long,java.lang.Object) -> f
    void putResize(long,java.lang.Object) -> g
    void resize(int) -> h
com.badlogic.gdx.utils.LongMap$Entries -> i0.w$a:
    com.badlogic.gdx.utils.LongMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.LongMap$Entry next() -> c
com.badlogic.gdx.utils.LongMap$Entry -> i0.w$b:
    java.lang.Object value -> b
    long key -> a
com.badlogic.gdx.utils.LongMap$MapIterator -> i0.w$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    com.badlogic.gdx.utils.LongMap map -> b
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.NumberUtils -> i0.x:
    int floatToIntBits(float) -> a
    int floatToIntColor(float) -> b
    int floatToRawIntBits(float) -> c
    float intToFloatColor(int) -> d
com.badlogic.gdx.utils.ObjectFloatMap -> i0.y:
    java.lang.Object[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries2 -> i
    int mask -> g
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries1 -> h
    float[] valueTable -> c
    int threshold -> e
    int size -> a
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries() -> b
    float get(java.lang.Object,float) -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void put(java.lang.Object,float) -> g
    void putResize(java.lang.Object,float) -> h
    void resize(int) -> i
    java.lang.String toString(java.lang.String,boolean) -> j
com.badlogic.gdx.utils.ObjectFloatMap$Entries -> i0.y$a:
    com.badlogic.gdx.utils.ObjectFloatMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectFloatMap$Entry -> i0.y$b:
    float value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectFloatMap$MapIterator -> i0.y$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectFloatMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap -> i0.z:
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> h
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> i
    int mask -> g
    int threshold -> e
    int size -> a
    void clear() -> a
    void clear(int) -> b
    boolean containsKey(java.lang.Object) -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> d
    int get(java.lang.Object,int) -> e
    int getAndIncrement(java.lang.Object,int,int) -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> g
    int locateKey(java.lang.Object) -> h
    int place(java.lang.Object) -> i
    void put(java.lang.Object,int) -> j
    void putResize(java.lang.Object,int) -> k
    void resize(int) -> l
    java.lang.String toString(java.lang.String,boolean) -> m
com.badlogic.gdx.utils.ObjectIntMap$Entries -> i0.z$a:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectIntMap$Entry -> i0.z$b:
    java.lang.Object key -> a
    int value -> b
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> i0.z$c:
    boolean valid -> e
    int currentIndex -> d
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap -> i0.a0:
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    com.badlogic.gdx.utils.ObjectMap$Values values1 -> j
    java.lang.Object dummy -> n
    com.badlogic.gdx.utils.ObjectMap$Values values2 -> k
    int size -> a
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> l
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> m
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> h
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> i
    void clear() -> a
    void clear(int) -> b
    boolean containsKey(java.lang.Object) -> c
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> d
    java.lang.Object get(java.lang.Object) -> e
    java.lang.Object get(java.lang.Object,java.lang.Object) -> f
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> g
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> h
    int locateKey(java.lang.Object) -> i
    int place(java.lang.Object) -> j
    java.lang.Object put(java.lang.Object,java.lang.Object) -> k
    void putResize(java.lang.Object,java.lang.Object) -> l
    java.lang.Object remove(java.lang.Object) -> m
    void resize(int) -> n
    java.lang.String toString(java.lang.String,boolean) -> o
    com.badlogic.gdx.utils.ObjectMap$Values values() -> p
com.badlogic.gdx.utils.ObjectMap$Entries -> i0.a0$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectMap$Entry -> i0.a0$b:
    java.lang.Object value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectMap$Keys -> i0.a0$c:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Keys iterator() -> c
    com.badlogic.gdx.utils.Array toArray() -> d
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> e
com.badlogic.gdx.utils.ObjectMap$MapIterator -> i0.a0$d:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap$Values -> i0.a0$e:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Values iterator() -> c
com.badlogic.gdx.utils.ObjectSet -> i0.b0:
    java.lang.Object[] keyTable -> b
    int mask -> f
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> g
    float loadFactor -> c
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> h
    int threshold -> d
    int shift -> e
    int size -> a
    boolean add(java.lang.Object) -> a
    void addResize(java.lang.Object) -> b
    void clear() -> c
    void clear(int) -> d
    boolean contains(java.lang.Object) -> e
    void ensureCapacity(int) -> f
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> g
    int locateKey(java.lang.Object) -> h
    int place(java.lang.Object) -> i
    void resize(int) -> j
    int tableSize(int,float) -> k
    java.lang.String toString(java.lang.String) -> l
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> i0.b0$a:
    com.badlogic.gdx.utils.ObjectSet set -> b
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> b
    void reset() -> c
com.badlogic.gdx.utils.OrderedMap -> i0.c0:
    com.badlogic.gdx.utils.Array keys -> o
    void clear() -> a
    void clear(int) -> b
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> d
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> g
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> h
    java.lang.Object put(java.lang.Object,java.lang.Object) -> k
    java.lang.Object remove(java.lang.Object) -> m
    java.lang.String toString(java.lang.String,boolean) -> o
    com.badlogic.gdx.utils.ObjectMap$Values values() -> p
    java.lang.Object removeIndex(int) -> q
com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries -> i0.c0$a:
    com.badlogic.gdx.utils.Array keys -> g
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys -> i0.c0$b:
    com.badlogic.gdx.utils.Array keys -> f
    void reset() -> b
    com.badlogic.gdx.utils.Array toArray() -> d
    com.badlogic.gdx.utils.Array toArray(com.badlogic.gdx.utils.Array) -> e
com.badlogic.gdx.utils.OrderedMap$OrderedMapValues -> i0.c0$c:
    com.badlogic.gdx.utils.Array keys -> f
    void reset() -> b
com.badlogic.gdx.utils.Pool -> i0.d0:
    com.badlogic.gdx.utils.Array freeObjects -> c
    int peak -> b
    int max -> a
    void discard(java.lang.Object) -> a
    void free(java.lang.Object) -> b
    void freeAll(com.badlogic.gdx.utils.Array) -> c
    java.lang.Object newObject() -> d
    java.lang.Object obtain() -> e
    void reset(java.lang.Object) -> f
com.badlogic.gdx.utils.Pool$Poolable -> i0.d0$a:
    void reset() -> b
com.badlogic.gdx.utils.Pools -> i0.e0:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array,boolean) -> b
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> c
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> d
    java.lang.Object obtain(java.lang.Class) -> e
com.badlogic.gdx.utils.PropertiesUtils -> i0.f0:
    void load(com.badlogic.gdx.utils.ObjectMap,java.io.Reader) -> a
com.badlogic.gdx.utils.Queue -> i0.g0:
    java.lang.Object[] values -> a
    int size -> d
    int head -> b
    com.badlogic.gdx.utils.Queue$QueueIterable iterable -> e
    int tail -> c
    void addLast(java.lang.Object) -> a
    java.lang.Object get(int) -> b
    java.lang.Object removeIndex(int) -> c
    void resize(int) -> d
com.badlogic.gdx.utils.Queue$QueueIterable -> i0.g0$a:
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Queue queue -> a
    com.badlogic.gdx.utils.Queue$QueueIterator iterator1 -> c
    com.badlogic.gdx.utils.Queue$QueueIterator iterator2 -> d
com.badlogic.gdx.utils.Queue$QueueIterator -> i0.g0$b:
    boolean allowRemove -> b
    int index -> c
    com.badlogic.gdx.utils.Queue queue -> a
    boolean valid -> d
com.badlogic.gdx.utils.ReflectionPool -> i0.h0:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> g
com.badlogic.gdx.utils.Scaling -> i0.i0:
    com.badlogic.gdx.utils.Scaling stretch -> g
    com.badlogic.gdx.utils.Scaling fillY -> f
    com.badlogic.gdx.math.Vector2 temp -> a
    com.badlogic.gdx.utils.Scaling fillX -> e
    com.badlogic.gdx.utils.Scaling fill -> d
    com.badlogic.gdx.utils.Scaling contain -> c
    com.badlogic.gdx.utils.Scaling fit -> b
    com.badlogic.gdx.utils.Scaling none -> j
    com.badlogic.gdx.utils.Scaling stretchY -> i
    com.badlogic.gdx.utils.Scaling stretchX -> h
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> i0.i0$a:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$2 -> i0.i0$b:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$3 -> i0.i0$c:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$4 -> i0.i0$d:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$5 -> i0.i0$e:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$6 -> i0.i0$f:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$7 -> i0.i0$g:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$8 -> i0.i0$h:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$9 -> i0.i0$i:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.SerializationException -> i0.j0:
    com.badlogic.gdx.utils.StringBuilder trace -> a
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoadRuntimeException -> i0.k0:
com.badlogic.gdx.utils.SharedLibraryLoader -> i0.l0:
    java.util.Random random -> j
    boolean isIos -> e
    boolean isAndroid -> f
    java.lang.String nativesJar -> a
    boolean isARM -> g
    boolean is64Bit -> h
    boolean isWindows -> b
    boolean isLinux -> c
    boolean isMac -> d
    java.util.HashSet loadedLibraries -> i
    void closeQuietly(java.io.Closeable) -> a
    java.lang.String crc(java.io.InputStream) -> b
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> c
    boolean isLoaded(java.lang.String) -> d
    void load(java.lang.String) -> e
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> f
    void loadFile(java.lang.String) -> g
    java.lang.String mapLibraryName(java.lang.String) -> h
    java.io.InputStream readFile(java.lang.String) -> i
    void setLoaded(java.lang.String) -> j
com.badlogic.gdx.utils.ShortArray -> i0.m0:
    short[] items -> a
    int size -> b
    boolean ordered -> c
    void add(short) -> a
    void clear() -> b
    short[] ensureCapacity(int) -> c
    short removeIndex(int) -> d
    short[] resize(int) -> e
    short[] toArray() -> f
com.badlogic.gdx.utils.SnapshotArray -> i0.n0:
    java.lang.Object[] snapshot -> e
    int snapshots -> g
    java.lang.Object[] recycled -> f
    void end() -> A
    void modified() -> B
    void clear() -> e
    void insert(int,java.lang.Object) -> k
    java.lang.Object pop() -> o
    java.lang.Object removeIndex(int) -> p
    void removeRange(int,int) -> q
    boolean removeValue(java.lang.Object,boolean) -> r
    void set(int,java.lang.Object) -> t
    void sort() -> u
    void sort(java.util.Comparator) -> v
    void truncate(int) -> x
    java.lang.Object[] begin() -> z
com.badlogic.gdx.utils.Sort -> i0.o0:
    com.badlogic.gdx.utils.TimSort timSort -> a
    com.badlogic.gdx.utils.Sort instance -> c
    com.badlogic.gdx.utils.ComparableTimSort comparableTimSort -> b
    com.badlogic.gdx.utils.Sort instance() -> a
    void sort(java.lang.Object[],int,int) -> b
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> c
com.badlogic.gdx.utils.StreamUtils -> i0.p0:
    byte[] EMPTY_BYTES -> a
    void closeQuietly(java.io.Closeable) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> b
    void copyStream(java.io.InputStream,java.io.OutputStream,byte[]) -> c
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> d
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> i0.p0$a:
com.badlogic.gdx.utils.StringBuilder -> i0.q0:
    char[] chars -> a
    char[] digits -> c
    int length -> b
    int indexOf(java.lang.String,int) -> A
    void insert0(int,java.lang.String) -> B
    void move(int,int) -> C
    int numChars(int,int) -> D
    int numChars(long,int) -> E
    com.badlogic.gdx.utils.StringBuilder replace(char,java.lang.String) -> F
    void replace0(int,int,java.lang.String) -> G
    void setLength(int) -> H
    java.lang.String substring(int,int) -> I
    com.badlogic.gdx.utils.StringBuilder append(char) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> b
    com.badlogic.gdx.utils.StringBuilder append(float) -> c
    com.badlogic.gdx.utils.StringBuilder append(int) -> d
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> e
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> f
    com.badlogic.gdx.utils.StringBuilder append(long) -> g
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> h
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> i
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> j
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> k
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> l
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> m
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> n
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> o
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> p
    com.badlogic.gdx.utils.StringBuilder append(char[],int,int) -> q
    void append0(char) -> r
    void append0(java.lang.CharSequence,int,int) -> s
    void append0(java.lang.String) -> t
    void append0(char[]) -> u
    void append0(char[],int,int) -> v
    void appendNull() -> w
    void clear() -> x
    void enlargeBuffer(int) -> y
    int indexOf(java.lang.String) -> z
com.badlogic.gdx.utils.TextFormatter -> i0.r0:
    com.badlogic.gdx.utils.StringBuilder buffer -> b
    java.text.MessageFormat messageFormat -> a
com.badlogic.gdx.utils.TimSort -> i0.s0:
    java.lang.Object[] tmp -> d
    int[] runBase -> g
    int[] runLen -> h
    int stackSize -> f
    int tmpCount -> e
    int minGallop -> c
    java.util.Comparator c -> b
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> b
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> e
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.TimeUtils -> i0.t0:
    long millis() -> a
    long nanoTime() -> b
com.badlogic.gdx.utils.Timer -> i0.u0:
    com.badlogic.gdx.utils.Timer$TimerThread thread -> c
    com.badlogic.gdx.utils.Array tasks -> a
    java.lang.Object threadLock -> b
    void delay(long) -> a
    com.badlogic.gdx.utils.Timer instance() -> b
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float,float) -> c
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float) -> d
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> e
    void start() -> f
    com.badlogic.gdx.utils.Timer$TimerThread thread() -> g
    long update(long,long) -> h
com.badlogic.gdx.utils.Timer$Task -> i0.u0$a:
    com.badlogic.gdx.utils.Timer timer -> e
    long executeTimeMillis -> b
    int repeatCount -> d
    com.badlogic.gdx.Application app -> a
    long intervalMillis -> c
    void cancel() -> a
    boolean isScheduled() -> b
com.badlogic.gdx.utils.Timer$TimerThread -> i0.u0$b:
    com.badlogic.gdx.utils.Timer instance -> d
    long pauseTimeMillis -> e
    com.badlogic.gdx.utils.Array instances -> c
    com.badlogic.gdx.Files files -> a
    com.badlogic.gdx.Application app -> b
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.utils.UBJsonReader -> i0.v0:
    boolean oldFormat -> a
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> a
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream) -> b
    com.badlogic.gdx.utils.JsonValue parse(java.io.DataInputStream,byte) -> c
    com.badlogic.gdx.utils.JsonValue parse(java.io.InputStream) -> d
    com.badlogic.gdx.utils.JsonValue parseArray(java.io.DataInputStream) -> e
    com.badlogic.gdx.utils.JsonValue parseData(java.io.DataInputStream,byte) -> f
    com.badlogic.gdx.utils.JsonValue parseObject(java.io.DataInputStream) -> g
    long parseSize(java.io.DataInputStream,byte,boolean,long) -> h
    long parseSize(java.io.DataInputStream,boolean,long) -> i
    java.lang.String parseString(java.io.DataInputStream,byte) -> j
    java.lang.String parseString(java.io.DataInputStream,boolean,byte) -> k
    java.lang.String readString(java.io.DataInputStream,long) -> l
    short readUChar(java.io.DataInputStream) -> m
    long readUInt(java.io.DataInputStream) -> n
    int readUShort(java.io.DataInputStream) -> o
com.badlogic.gdx.utils.XmlReader -> i0.w0:
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _xml_indicies -> l
    short[] _xml_index_offsets -> k
    byte[] _xml_trans_actions -> n
    com.badlogic.gdx.utils.XmlReader$Element current -> c
    char[] _xml_trans_keys -> h
    byte[] _xml_trans_targs -> m
    com.badlogic.gdx.utils.XmlReader$Element root -> b
    com.badlogic.gdx.utils.StringBuilder textBuffer -> d
    byte[] _xml_key_offsets -> g
    byte[] _xml_range_lengths -> j
    byte[] _xml_single_lengths -> i
    java.lang.String entitiesText -> e
    byte[] _xml_actions -> f
    void attribute(java.lang.String,java.lang.String) -> a
    void close() -> b
    java.lang.String entity(java.lang.String) -> c
    byte[] init__xml_actions_0() -> d
    short[] init__xml_index_offsets_0() -> e
    byte[] init__xml_indicies_0() -> f
    byte[] init__xml_key_offsets_0() -> g
    byte[] init__xml_range_lengths_0() -> h
    byte[] init__xml_single_lengths_0() -> i
    byte[] init__xml_trans_actions_0() -> j
    char[] init__xml_trans_keys_0() -> k
    byte[] init__xml_trans_targs_0() -> l
    void open(java.lang.String) -> m
    com.badlogic.gdx.utils.XmlReader$Element parse(com.badlogic.gdx.files.FileHandle) -> n
    com.badlogic.gdx.utils.XmlReader$Element parse(java.io.Reader) -> o
    com.badlogic.gdx.utils.XmlReader$Element parse(char[],int,int) -> p
    void text(java.lang.String) -> q
com.badlogic.gdx.utils.XmlReader$Element -> i0.w0$a:
    com.badlogic.gdx.utils.XmlReader$Element parent -> e
    java.lang.String name -> a
    com.badlogic.gdx.utils.Array children -> c
    com.badlogic.gdx.utils.ObjectMap attributes -> b
    java.lang.String text -> d
    void addChild(com.badlogic.gdx.utils.XmlReader$Element) -> a
    java.lang.String get(java.lang.String,java.lang.String) -> b
    java.lang.String getAttribute(java.lang.String) -> c
    java.lang.String getAttribute(java.lang.String,java.lang.String) -> d
    com.badlogic.gdx.utils.XmlReader$Element getChild(int) -> e
    com.badlogic.gdx.utils.XmlReader$Element getChildByName(java.lang.String) -> f
    int getChildCount() -> g
    com.badlogic.gdx.utils.Array getChildrenByName(java.lang.String) -> h
    float getFloatAttribute(java.lang.String,float) -> i
    int getIntAttribute(java.lang.String) -> j
    int getIntAttribute(java.lang.String,int) -> k
    java.lang.String getName() -> l
    java.lang.String getText() -> m
    boolean hasAttribute(java.lang.String) -> n
    void removeChild(com.badlogic.gdx.utils.XmlReader$Element) -> o
    void setAttribute(java.lang.String,java.lang.String) -> p
    void setText(java.lang.String) -> q
    java.lang.String toString(java.lang.String) -> r
com.badlogic.gdx.utils.async.AsyncExecutor -> j0.a:
    java.util.concurrent.ExecutorService executor -> a
    void dispose() -> a
    com.badlogic.gdx.utils.async.AsyncResult submit(com.badlogic.gdx.utils.async.AsyncTask) -> k
com.badlogic.gdx.utils.async.AsyncExecutor$1 -> j0.a$a:
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> b
    java.lang.String val$name -> a
com.badlogic.gdx.utils.async.AsyncExecutor$2 -> j0.a$b:
    com.badlogic.gdx.utils.async.AsyncTask val$task -> a
    com.badlogic.gdx.utils.async.AsyncExecutor this$0 -> b
com.badlogic.gdx.utils.async.AsyncResult -> j0.b:
    java.util.concurrent.Future future -> a
    java.lang.Object get() -> a
    boolean isDone() -> b
com.badlogic.gdx.utils.async.AsyncTask -> j0.c:
com.badlogic.gdx.utils.async.ThreadUtils -> j0.d:
    void yield() -> a
com.badlogic.gdx.utils.reflect.ArrayReflection -> k0.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> b
com.badlogic.gdx.utils.reflect.ClassReflection -> k0.b:
    java.lang.Class forName(java.lang.String) -> a
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> b
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> c
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> d
    java.lang.String getSimpleName(java.lang.Class) -> e
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> f
    boolean isMemberClass(java.lang.Class) -> g
    boolean isStaticClass(java.lang.Class) -> h
    java.lang.Object newInstance(java.lang.Class) -> i
com.badlogic.gdx.utils.reflect.Constructor -> k0.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Object newInstance(java.lang.Object[]) -> b
    void setAccessible(boolean) -> c
com.badlogic.gdx.utils.reflect.Field -> k0.d:
    java.lang.reflect.Field field -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Class getDeclaringClass() -> b
    java.lang.Class getElementType(int) -> c
    java.lang.String getName() -> d
    java.lang.Class getType() -> e
    boolean isAccessible() -> f
    boolean isAnnotationPresent(java.lang.Class) -> g
    boolean isStatic() -> h
    boolean isSynthetic() -> i
    boolean isTransient() -> j
    void set(java.lang.Object,java.lang.Object) -> k
    void setAccessible(boolean) -> l
com.badlogic.gdx.utils.reflect.ReflectionException -> k0.e:
com.badlogic.gdx.utils.viewport.FillViewport -> l0.a:
com.badlogic.gdx.utils.viewport.ScalingViewport -> l0.b:
    com.badlogic.gdx.utils.Scaling scaling -> i
    void update(int,int,boolean) -> p
com.badlogic.gdx.utils.viewport.StretchViewport -> l0.c:
com.badlogic.gdx.utils.viewport.Viewport -> l0.d:
    com.badlogic.gdx.graphics.Camera camera -> a
    int screenWidth -> f
    float worldHeight -> c
    int screenHeight -> g
    float worldWidth -> b
    int screenX -> d
    int screenY -> e
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply() -> a
    void apply(boolean) -> b
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> c
    com.badlogic.gdx.graphics.Camera getCamera() -> d
    int getScreenHeight() -> e
    int getScreenWidth() -> f
    int getScreenX() -> g
    int getScreenY() -> h
    float getWorldHeight() -> i
    float getWorldWidth() -> j
    void setCamera(com.badlogic.gdx.graphics.Camera) -> k
    void setScreenBounds(int,int,int,int) -> l
    void setWorldSize(float,float) -> m
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> n
    void update(int,int) -> o
    void update(int,int,boolean) -> p
com.esotericsoftware.kryo.ClassResolver -> m0.a:
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
    void reset() -> b
    com.esotericsoftware.kryo.Registration registerImplicit(java.lang.Class) -> c
    com.esotericsoftware.kryo.Registration register(com.esotericsoftware.kryo.Registration) -> d
    com.esotericsoftware.kryo.Registration readClass(com.esotericsoftware.kryo.io.Input) -> e
    com.esotericsoftware.kryo.Registration getRegistration(int) -> f
    com.esotericsoftware.kryo.Registration getRegistration(java.lang.Class) -> g
    com.esotericsoftware.kryo.Registration writeClass(com.esotericsoftware.kryo.io.Output,java.lang.Class) -> h
com.esotericsoftware.kryo.DefaultSerializer -> m0.b:
com.esotericsoftware.kryo.Generics -> m0.c:
    java.util.Map typeVar2class -> a
    com.esotericsoftware.kryo.Generics parentScope -> b
    java.util.Map getMappings() -> a
    com.esotericsoftware.kryo.Generics getParentScope() -> b
    void resetParentScope() -> c
    void setParentScope(com.esotericsoftware.kryo.Generics) -> d
com.esotericsoftware.kryo.Kryo -> m0.d:
    int maxDepth -> j
    boolean autoReset -> k
    int depth -> i
    com.esotericsoftware.kryo.util.IntArray readReferenceIds -> p
    java.lang.Object readObject -> s
    boolean asmEnabled -> w
    com.esotericsoftware.kryo.factories.SerializerFactory defaultSerializer -> a
    int nextRegisterID -> e
    com.esotericsoftware.kryo.ReferenceResolver referenceResolver -> o
    boolean references -> q
    java.util.ArrayList defaultSerializers -> b
    int lowPriorityDefaultSerializerCount -> c
    boolean copyReferences -> r
    com.esotericsoftware.kryo.Generics genericsScope -> v
    com.esotericsoftware.kryo.ClassResolver classResolver -> d
    java.lang.Object needsCopyReference -> u
    com.esotericsoftware.kryo.util.ObjectMap context -> m
    com.esotericsoftware.kryo.util.ObjectMap graphContext -> n
    int copyDepth -> t
    com.esotericsoftware.kryo.StreamFactory streamFactory -> x
    boolean registrationRequired -> h
    java.lang.Thread thread -> l
    java.lang.ClassLoader classLoader -> f
    org.objenesis.strategy.InstantiatorStrategy strategy -> g
    com.esotericsoftware.kryo.Registration register(java.lang.Class,com.esotericsoftware.kryo.Serializer) -> A
    void reset() -> B
    boolean setReferences(boolean) -> C
    void setRegistrationRequired(boolean) -> D
    com.esotericsoftware.kryo.Registration writeClass(com.esotericsoftware.kryo.io.Output,java.lang.Class) -> E
    void writeClassAndObject(com.esotericsoftware.kryo.io.Output,java.lang.Object) -> F
    void writeObject(com.esotericsoftware.kryo.io.Output,java.lang.Object,com.esotericsoftware.kryo.Serializer) -> G
    void writeObjectOrNull(com.esotericsoftware.kryo.io.Output,java.lang.Object,com.esotericsoftware.kryo.Serializer) -> H
    boolean writeReferenceOrNull(com.esotericsoftware.kryo.io.Output,java.lang.Object,boolean) -> I
    void addDefaultSerializer(java.lang.Class,java.lang.Class) -> a
    void beginObject() -> b
    java.lang.ClassLoader getClassLoader() -> c
    com.esotericsoftware.kryo.util.ObjectMap getContext() -> d
    com.esotericsoftware.kryo.Serializer getDefaultSerializer(java.lang.Class) -> e
    int getDepth() -> f
    com.esotericsoftware.kryo.Generics getGenericsScope() -> g
    int getNextRegistrationId() -> h
    com.esotericsoftware.kryo.ReferenceResolver getReferenceResolver() -> i
    boolean getReferences() -> j
    com.esotericsoftware.kryo.Registration getRegistration(java.lang.Class) -> k
    com.esotericsoftware.kryo.Serializer getSerializer(java.lang.Class) -> l
    boolean isFinal(java.lang.Class) -> m
    boolean isRegistrationRequired() -> n
    com.esotericsoftware.kryo.Serializer newDefaultSerializer(java.lang.Class) -> o
    java.lang.Object newInstance(java.lang.Class) -> p
    org.objenesis.instantiator.ObjectInstantiator newInstantiator(java.lang.Class) -> q
    void popGenericsScope() -> r
    void pushGenericsScope(java.lang.Class,com.esotericsoftware.kryo.Generics) -> s
    com.esotericsoftware.kryo.Registration readClass(com.esotericsoftware.kryo.io.Input) -> t
    java.lang.Object readClassAndObject(com.esotericsoftware.kryo.io.Input) -> u
    java.lang.Object readObject(com.esotericsoftware.kryo.io.Input,java.lang.Class,com.esotericsoftware.kryo.Serializer) -> v
    java.lang.Object readObjectOrNull(com.esotericsoftware.kryo.io.Input,java.lang.Class,com.esotericsoftware.kryo.Serializer) -> w
    int readReferenceOrNull(com.esotericsoftware.kryo.io.Input,java.lang.Class,boolean) -> x
    void reference(java.lang.Object) -> y
    com.esotericsoftware.kryo.Registration register(java.lang.Class) -> z
com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy -> m0.d$a:
    org.objenesis.strategy.InstantiatorStrategy fallbackStrategy -> a
    org.objenesis.instantiator.ObjectInstantiator newInstantiatorOf(java.lang.Class) -> a
com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy$1 -> m0.d$a$a:
    com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy this$0 -> c
    java.lang.Class val$type -> b
    com.esotericsoftware.reflectasm.ConstructorAccess val$access -> a
    java.lang.Object newInstance() -> a
com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy$2 -> m0.d$a$b:
    com.esotericsoftware.kryo.Kryo$DefaultInstantiatorStrategy this$0 -> c
    java.lang.reflect.Constructor val$constructor -> a
    java.lang.Class val$type -> b
    java.lang.Object newInstance() -> a
com.esotericsoftware.kryo.Kryo$DefaultSerializerEntry -> m0.d$b:
    com.esotericsoftware.kryo.factories.SerializerFactory serializerFactory -> b
    java.lang.Class type -> a
com.esotericsoftware.kryo.KryoException -> m0.e:
    java.lang.StringBuffer trace -> a
com.esotericsoftware.kryo.KryoSerializable -> m0.f:
    void read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input) -> a
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output) -> b
com.esotericsoftware.kryo.ReferenceResolver -> m0.g:
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
    void reset() -> b
    int nextReadId(java.lang.Class) -> c
    void setReadObject(int,java.lang.Object) -> d
    int addWrittenObject(java.lang.Object) -> e
    int getWrittenId(java.lang.Object) -> f
    java.lang.Object getReadObject(java.lang.Class,int) -> g
    boolean useReferences(java.lang.Class) -> h
com.esotericsoftware.kryo.Registration -> m0.h:
    com.esotericsoftware.kryo.Serializer serializer -> c
    int id -> b
    java.lang.Class type -> a
    org.objenesis.instantiator.ObjectInstantiator instantiator -> d
    int getId() -> a
    org.objenesis.instantiator.ObjectInstantiator getInstantiator() -> b
    com.esotericsoftware.kryo.Serializer getSerializer() -> c
    java.lang.Class getType() -> d
    void setInstantiator(org.objenesis.instantiator.ObjectInstantiator) -> e
    void setSerializer(com.esotericsoftware.kryo.Serializer) -> f
com.esotericsoftware.kryo.Serializer -> m0.i:
    boolean acceptsNull -> a
    boolean immutable -> b
    boolean getAcceptsNull() -> a
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void setAcceptsNull(boolean) -> c
    void setGenerics(com.esotericsoftware.kryo.Kryo,java.lang.Class[]) -> d
    void setImmutable(boolean) -> e
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
com.esotericsoftware.kryo.StreamFactory -> m0.j:
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
com.esotericsoftware.kryo.factories.ReflectionSerializerFactory -> n0.a:
    java.lang.Class serializerClass -> a
    com.esotericsoftware.kryo.Serializer makeSerializer(com.esotericsoftware.kryo.Kryo,java.lang.Class) -> a
    com.esotericsoftware.kryo.Serializer makeSerializer(com.esotericsoftware.kryo.Kryo,java.lang.Class,java.lang.Class) -> b
com.esotericsoftware.kryo.factories.SerializerFactory -> n0.b:
    com.esotericsoftware.kryo.Serializer makeSerializer(com.esotericsoftware.kryo.Kryo,java.lang.Class) -> a
com.esotericsoftware.kryo.io.ByteBufferInput -> o0.a:
    java.nio.ByteOrder byteOrder -> i
    java.nio.ByteBuffer niobuffer -> g
    java.nio.ByteOrder nativeOrder -> j
    boolean varIntsEnabled -> h
    int readInt() -> A
    int readInt_slow(boolean) -> B
    long readLong() -> C
    long readLong_slow(boolean) -> D
    void readUtf8(int) -> E
    int readUtf8Length(int) -> F
    int readUtf8Length_slow(int) -> G
    void readUtf8_slow(int,int) -> H
    long readVarLong(boolean) -> I
    void setBuffer(java.nio.ByteBuffer) -> J
    boolean readBoolean() -> a
    byte readByte() -> b
    byte[] readBytes(int) -> c
    char readChar() -> d
    char[] readChars(int) -> e
    double readDouble() -> f
    double[] readDoubles(int) -> g
    float readFloat() -> h
    float[] readFloats(int) -> i
    int readInt(boolean) -> j
    long readLong(boolean) -> l
    short readShort() -> n
    short[] readShorts(int) -> o
    java.lang.String readString() -> p
    java.lang.StringBuilder readStringBuilder() -> q
    int readVarInt(boolean) -> r
    int require(int) -> s
    int fill(java.nio.ByteBuffer,int,int) -> u
    boolean isNativeOrder() -> v
    int optional(int) -> w
    java.lang.String readAscii() -> x
    java.lang.String readAscii_slow() -> y
    void readBytes(byte[],int,int) -> z
com.esotericsoftware.kryo.io.ByteBufferOutput -> o0.b:
    java.nio.ByteOrder nativeOrder -> i
    java.nio.ByteBuffer niobuffer -> f
    java.nio.ByteOrder byteOrder -> h
    boolean varIntsEnabled -> g
    void writeLong(long) -> A
    void writeString_slow(java.lang.CharSequence,int,int) -> B
    void writeUtf8Length(int) -> C
    int writeVarLong(long,boolean) -> D
    void writeBoolean(boolean) -> a
    void writeByte(byte) -> b
    void writeByte(int) -> c
    void writeBytes(byte[]) -> d
    void writeChar(char) -> e
    void writeChars(char[]) -> f
    void writeDouble(double) -> g
    void writeDoubles(double[]) -> h
    void writeFloat(float) -> i
    void writeFloats(float[]) -> j
    int writeInt(int,boolean) -> k
    int writeLong(long,boolean) -> m
    void writeShort(int) -> o
    void writeShorts(short[]) -> p
    void writeString(java.lang.CharSequence) -> q
    void writeString(java.lang.String) -> r
    int writeVarInt(int,boolean) -> s
    boolean isNativeOrder() -> t
    boolean require(int) -> u
    void setBuffer(java.nio.ByteBuffer) -> v
    void setBuffer(java.nio.ByteBuffer,int) -> w
    void writeAscii_slow(java.lang.String,int) -> x
    void writeBytes(byte[],int,int) -> y
    void writeInt(int) -> z
com.esotericsoftware.kryo.io.Input -> o0.c:
    char[] chars -> e
    java.io.InputStream inputStream -> f
    long total -> d
    int capacity -> b
    int limit -> c
    int position -> a
    boolean readBoolean() -> a
    byte readByte() -> b
    byte[] readBytes(int) -> c
    char readChar() -> d
    char[] readChars(int) -> e
    double readDouble() -> f
    double[] readDoubles(int) -> g
    float readFloat() -> h
    float[] readFloats(int) -> i
    int readInt(boolean) -> j
    int[] readInts(int,boolean) -> k
    long readLong(boolean) -> l
    long[] readLongs(int,boolean) -> m
    short readShort() -> n
    short[] readShorts(int) -> o
    java.lang.String readString() -> p
    java.lang.StringBuilder readStringBuilder() -> q
    int readVarInt(boolean) -> r
    int require(int) -> s
    void skip(int) -> t
com.esotericsoftware.kryo.io.Output -> o0.d:
    java.io.OutputStream outputStream -> e
    long total -> b
    int capacity -> d
    int position -> c
    int maxCapacity -> a
    void writeBoolean(boolean) -> a
    void writeByte(byte) -> b
    void writeByte(int) -> c
    void writeBytes(byte[]) -> d
    void writeChar(char) -> e
    void writeChars(char[]) -> f
    void writeDouble(double) -> g
    void writeDoubles(double[]) -> h
    void writeFloat(float) -> i
    void writeFloats(float[]) -> j
    int writeInt(int,boolean) -> k
    void writeInts(int[],boolean) -> l
    int writeLong(long,boolean) -> m
    void writeLongs(long[],boolean) -> n
    void writeShort(int) -> o
    void writeShorts(short[]) -> p
    void writeString(java.lang.CharSequence) -> q
    void writeString(java.lang.String) -> r
    int writeVarInt(int,boolean) -> s
com.esotericsoftware.kryo.serializers.CollectionSerializer -> p0.a:
    java.lang.Class genericType -> f
    java.lang.Class elementClass -> e
    com.esotericsoftware.kryo.Serializer serializer -> d
    boolean elementsCanBeNull -> c
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void setGenerics(com.esotericsoftware.kryo.Kryo,java.lang.Class[]) -> d
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Collection create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    java.util.Collection read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> h
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Collection) -> i
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$BooleanArraySerializer -> p0.b:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    boolean[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,boolean[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$ByteArraySerializer -> p0.c:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    byte[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,byte[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$CharArraySerializer -> p0.d:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    char[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,char[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$DoubleArraySerializer -> p0.e:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    double[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,double[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$FloatArraySerializer -> p0.f:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    float[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,float[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$IntArraySerializer -> p0.g:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    int[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,int[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$LongArraySerializer -> p0.h:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    long[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,long[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$ObjectArraySerializer -> p0.i:
    java.lang.Class[] generics -> e
    boolean elementsAreSameType -> c
    boolean elementsCanBeNull -> d
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void setGenerics(com.esotericsoftware.kryo.Kryo,java.lang.Class[]) -> d
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Object[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$ShortArraySerializer -> p0.j:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    short[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,short[]) -> h
com.esotericsoftware.kryo.serializers.DefaultArraySerializers$StringArraySerializer -> p0.k:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.String[] read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.String[]) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$BigDecimalSerializer -> p0.l:
    com.esotericsoftware.kryo.serializers.DefaultSerializers$BigIntegerSerializer bigIntegerSerializer -> c
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.math.BigDecimal read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.math.BigDecimal) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$BigIntegerSerializer -> p0.m:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.math.BigInteger read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.math.BigInteger) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$BooleanSerializer -> p0.n:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Boolean read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Boolean) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$ByteSerializer -> p0.o:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Byte read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Byte) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CalendarSerializer -> p0.p:
    com.esotericsoftware.kryo.serializers.DefaultSerializers$TimeZoneSerializer timeZoneSerializer -> c
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Calendar read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Calendar) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CharSerializer -> p0.q:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Character read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Character) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$ClassSerializer -> p0.r:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Class read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Class) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsEmptyListSerializer -> p0.s:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsEmptyMapSerializer -> p0.t:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsEmptySetSerializer -> p0.u:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsSingletonListSerializer -> p0.v:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.List read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.List) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsSingletonMapSerializer -> p0.w:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Map read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Map) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CollectionsSingletonSetSerializer -> p0.x:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Set read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Set) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$CurrencySerializer -> p0.y:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Currency read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Currency) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$DateSerializer -> p0.z:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Date create(com.esotericsoftware.kryo.Kryo,java.lang.Class,long) -> g
    java.util.Date read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> h
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Date) -> i
com.esotericsoftware.kryo.serializers.DefaultSerializers$DoubleSerializer -> p0.a0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Double read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Double) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$EnumSerializer -> p0.b0:
    java.lang.Object[] enumConstants -> c
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Enum read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Enum) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$EnumSetSerializer -> p0.c0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.EnumSet read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.EnumSet) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$FloatSerializer -> p0.d0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Float read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Float) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$IntSerializer -> p0.e0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Integer read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Integer) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$KryoSerializableSerializer -> p0.f0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    com.esotericsoftware.kryo.KryoSerializable read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,com.esotericsoftware.kryo.KryoSerializable) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$LocaleSerializer -> p0.g0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Locale create(java.lang.String,java.lang.String,java.lang.String) -> g
    boolean isSameLocale(java.util.Locale,java.lang.String,java.lang.String,java.lang.String) -> h
    java.util.Locale read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> i
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Locale) -> j
com.esotericsoftware.kryo.serializers.DefaultSerializers$LongSerializer -> p0.h0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Long read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Long) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$ShortSerializer -> p0.i0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.Short read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Short) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$StringBufferSerializer -> p0.j0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.StringBuffer read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.StringBuffer) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$StringBuilderSerializer -> p0.k0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.StringBuilder read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.StringBuilder) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$StringSerializer -> p0.l0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.lang.String read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.String) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$TimeZoneSerializer -> p0.m0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.TimeZone read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.TimeZone) -> h
com.esotericsoftware.kryo.serializers.DefaultSerializers$TreeMapSerializer -> p0.n0:
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Map create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Map) -> i
com.esotericsoftware.kryo.serializers.DefaultSerializers$TreeSetSerializer -> p0.o0:
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Collection create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Collection) -> i
    java.util.TreeSet create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> j
com.esotericsoftware.kryo.serializers.DefaultSerializers$VoidSerializer -> p0.p0:
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
com.esotericsoftware.kryo.serializers.FieldSerializer -> p0.q0:
    com.esotericsoftware.kryo.Generics genericsScope -> g
    java.lang.reflect.Method sortFieldsByOffsetMethod -> k
    java.lang.reflect.TypeVariable[] typeParameters -> d
    java.lang.Class[] generics -> f
    boolean unsafeAvailable -> i
    java.lang.Class unsafeUtilClass -> j
    com.esotericsoftware.kryo.serializers.FieldSerializer$CachedField[] fields -> e
    boolean hasObjectFields -> h
    java.lang.Class type -> c
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void setGenerics(com.esotericsoftware.kryo.Kryo,java.lang.Class[]) -> d
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    int compare(com.esotericsoftware.kryo.serializers.FieldSerializer$CachedField,com.esotericsoftware.kryo.serializers.FieldSerializer$CachedField) -> g
    java.lang.Object create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> h
    void rebuildCachedFields() -> i
    void rebuildCachedFields(boolean) -> j
com.esotericsoftware.kryo.serializers.FieldSerializer$CachedField -> p0.q0$a:
    long offset -> c
    int accessIndex -> b
    java.lang.reflect.Field field -> a
    boolean varIntsEnabled -> d
    void read(com.esotericsoftware.kryo.io.Input,java.lang.Object) -> a
    void write(com.esotericsoftware.kryo.io.Output,java.lang.Object) -> b
com.esotericsoftware.kryo.serializers.MapSerializer -> p0.r0:
    java.lang.Class valueGenericType -> j
    java.lang.Class keyGenericType -> i
    boolean keysCanBeNull -> g
    boolean valuesCanBeNull -> h
    com.esotericsoftware.kryo.Serializer keySerializer -> e
    java.lang.Class valueClass -> d
    java.lang.Class keyClass -> c
    com.esotericsoftware.kryo.Serializer valueSerializer -> f
    java.lang.Object read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> b
    void setGenerics(com.esotericsoftware.kryo.Kryo,java.lang.Class[]) -> d
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.lang.Object) -> f
    java.util.Map create(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> g
    java.util.Map read(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Input,java.lang.Class) -> h
    void write(com.esotericsoftware.kryo.Kryo,com.esotericsoftware.kryo.io.Output,java.util.Map) -> i
com.esotericsoftware.kryo.util.DefaultClassResolver -> q0.a:
    com.esotericsoftware.kryo.util.ObjectMap nameToClass -> f
    com.esotericsoftware.kryo.Registration memoizedClassValue -> k
    com.esotericsoftware.kryo.util.IntMap idToRegistration -> b
    com.esotericsoftware.kryo.util.ObjectMap classToRegistration -> c
    java.lang.Class memoizedClass -> j
    int memoizedClassId -> h
    com.esotericsoftware.kryo.util.IntMap nameIdToClass -> e
    com.esotericsoftware.kryo.util.IdentityObjectIntMap classToNameId -> d
    int nextNameId -> g
    com.esotericsoftware.kryo.Kryo kryo -> a
    com.esotericsoftware.kryo.Registration memoizedClassIdValue -> i
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
    void reset() -> b
    com.esotericsoftware.kryo.Registration registerImplicit(java.lang.Class) -> c
    com.esotericsoftware.kryo.Registration register(com.esotericsoftware.kryo.Registration) -> d
    com.esotericsoftware.kryo.Registration readClass(com.esotericsoftware.kryo.io.Input) -> e
    com.esotericsoftware.kryo.Registration getRegistration(int) -> f
    com.esotericsoftware.kryo.Registration getRegistration(java.lang.Class) -> g
    com.esotericsoftware.kryo.Registration writeClass(com.esotericsoftware.kryo.io.Output,java.lang.Class) -> h
    java.lang.Class getTypeByName(java.lang.String) -> i
    com.esotericsoftware.kryo.Registration readName(com.esotericsoftware.kryo.io.Input) -> j
    void writeName(com.esotericsoftware.kryo.io.Output,java.lang.Class,com.esotericsoftware.kryo.Registration) -> k
com.esotericsoftware.kryo.util.DefaultStreamFactory -> q0.b:
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
com.esotericsoftware.kryo.util.IdentityObjectIntMap -> q0.c:
    java.lang.Object[] keyTable -> b
    int stashCapacity -> j
    int[] valueTable -> c
    int pushIterations -> k
    float loadFactor -> f
    int mask -> h
    int threshold -> i
    int hashShift -> g
    int capacity -> d
    int stashSize -> e
    int size -> a
    void clear() -> a
    int get(java.lang.Object,int) -> b
    int getStash(java.lang.Object,int) -> c
    int hash2(int) -> d
    int hash3(int) -> e
    void push(java.lang.Object,int,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> f
    void put(java.lang.Object,int) -> g
    void putResize(java.lang.Object,int) -> h
    void putStash(java.lang.Object,int) -> i
    void resize(int) -> j
com.esotericsoftware.kryo.util.IntArray -> q0.d:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    int pop() -> b
    int[] resize(int) -> c
com.esotericsoftware.kryo.util.IntMap -> q0.e:
    int stashCapacity -> l
    java.lang.Object[] valueTable -> c
    int pushIterations -> m
    java.lang.Object zeroValue -> f
    float loadFactor -> h
    int mask -> j
    int threshold -> k
    int hashShift -> i
    int capacity -> d
    int stashSize -> e
    int size -> a
    int[] keyTable -> b
    boolean hasZeroValue -> g
    void clear() -> a
    java.lang.Object get(int) -> b
    java.lang.Object getStash(int,java.lang.Object) -> c
    int hash2(int) -> d
    int hash3(int) -> e
    void push(int,java.lang.Object,int,int,int,int,int,int) -> f
    java.lang.Object put(int,java.lang.Object) -> g
    void putResize(int,java.lang.Object) -> h
    void putStash(int,java.lang.Object) -> i
    void resize(int) -> j
com.esotericsoftware.kryo.util.MapReferenceResolver -> q0.f:
    com.esotericsoftware.kryo.util.IdentityObjectIntMap writtenObjects -> b
    java.util.ArrayList readObjects -> c
    com.esotericsoftware.kryo.Kryo kryo -> a
    void setKryo(com.esotericsoftware.kryo.Kryo) -> a
    void reset() -> b
    int nextReadId(java.lang.Class) -> c
    void setReadObject(int,java.lang.Object) -> d
    int addWrittenObject(java.lang.Object) -> e
    int getWrittenId(java.lang.Object) -> f
    java.lang.Object getReadObject(java.lang.Class,int) -> g
    boolean useReferences(java.lang.Class) -> h
com.esotericsoftware.kryo.util.ObjectMap -> q0.g:
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    int stashCapacity -> j
    int pushIterations -> k
    float loadFactor -> f
    int mask -> h
    int threshold -> i
    int hashShift -> g
    int capacity -> d
    int stashSize -> e
    java.util.Random random -> l
    int size -> a
    void clear() -> a
    java.lang.Object get(java.lang.Object) -> b
    java.lang.Object getStash(java.lang.Object) -> c
    int hash2(int) -> d
    int hash3(int) -> e
    int nextPowerOfTwo(int) -> f
    void push(java.lang.Object,java.lang.Object,int,java.lang.Object,int,java.lang.Object,int,java.lang.Object) -> g
    java.lang.Object put(java.lang.Object,java.lang.Object) -> h
    void putResize(java.lang.Object,java.lang.Object) -> i
    void putStash(java.lang.Object,java.lang.Object) -> j
    java.lang.Object put_internal(java.lang.Object,java.lang.Object) -> k
    void resize(int) -> l
com.esotericsoftware.kryo.util.Util -> q0.h:
    boolean isAndroid -> a
    java.lang.String className(java.lang.Class) -> a
    int getDimensionCount(java.lang.Class) -> b
    java.lang.Class getElementClass(java.lang.Class) -> c
    java.lang.Class getWrapperClass(java.lang.Class) -> d
    boolean isWrapperClass(java.lang.Class) -> e
    void log(java.lang.String,java.lang.Object) -> f
    java.lang.String string(java.lang.Object) -> g
com.esotericsoftware.kryonet.Client -> r0.a:
    int emptySelects -> o
    java.lang.Thread updateThread -> v
    boolean tcpRegistered -> p
    java.lang.Object tcpRegistrationLock -> r
    java.lang.Object udpRegistrationLock -> s
    boolean udpRegistered -> q
    com.esotericsoftware.kryonet.Serialization serialization -> m
    boolean shutdown -> t
    int connectUdpPort -> z
    com.esotericsoftware.kryonet.ClientDiscoveryHandler discoveryHandler -> B
    java.lang.Object updateLock -> u
    int connectTcpPort -> y
    java.net.InetAddress connectHost -> x
    java.nio.channels.Selector selector -> n
    int connectTimeout -> w
    boolean isClosed -> A
    void addListener(com.esotericsoftware.kryonet.Listener) -> a
    void close() -> b
    com.esotericsoftware.kryo.Kryo getKryo() -> d
    void connect(int,java.lang.String,int,int) -> o
    void connect(int,java.net.InetAddress,int,int) -> p
    java.lang.Thread getUpdateThread() -> q
    void keepAlive() -> r
    void reconnect() -> s
    void reconnect(int) -> t
    void start() -> u
    void stop() -> v
    void update(int) -> w
com.esotericsoftware.kryonet.ClientDiscoveryHandler -> r0.b:
    com.esotericsoftware.kryonet.ClientDiscoveryHandler DEFAULT -> a
com.esotericsoftware.kryonet.ClientDiscoveryHandler$1 -> r0.b$a:
com.esotericsoftware.kryonet.Connection -> r0.c:
    long lastPingSendTime -> j
    java.lang.Object listenerLock -> h
    com.esotericsoftware.kryonet.TcpConnection tcp -> d
    com.esotericsoftware.kryonet.Listener[] listeners -> g
    int returnTripTime -> k
    java.net.InetSocketAddress udpRemoteAddress -> f
    int lastPingID -> i
    boolean isConnected -> l
    com.esotericsoftware.kryonet.EndPoint endPoint -> c
    java.lang.String name -> b
    int id -> a
    com.esotericsoftware.kryonet.UdpConnection udp -> e
    void addListener(com.esotericsoftware.kryonet.Listener) -> a
    void close() -> b
    int getID() -> c
    void initialize(com.esotericsoftware.kryonet.Serialization,int,int) -> e
    boolean isConnected() -> f
    boolean isIdle() -> g
    void notifyConnected() -> h
    void notifyDisconnected() -> i
    void notifyIdle() -> j
    void notifyReceived(java.lang.Object) -> k
    int sendTCP(java.lang.Object) -> l
    int sendUDP(java.lang.Object) -> m
    void setConnected(boolean) -> n
com.esotericsoftware.kryonet.EndPoint -> r0.d:
    com.esotericsoftware.kryo.Kryo getKryo() -> d
com.esotericsoftware.kryonet.FrameworkMessage -> r0.e:
    com.esotericsoftware.kryonet.FrameworkMessage$KeepAlive keepAlive -> a
com.esotericsoftware.kryonet.FrameworkMessage$DiscoverHost -> r0.e$a:
com.esotericsoftware.kryonet.FrameworkMessage$KeepAlive -> r0.e$b:
com.esotericsoftware.kryonet.FrameworkMessage$Ping -> r0.e$c:
    int id -> b
    boolean isReply -> c
com.esotericsoftware.kryonet.FrameworkMessage$RegisterTCP -> r0.e$d:
    int connectionID -> b
com.esotericsoftware.kryonet.FrameworkMessage$RegisterUDP -> r0.e$e:
    int connectionID -> b
com.esotericsoftware.kryonet.KryoNetException -> r0.f:
com.esotericsoftware.kryonet.KryoSerialization -> r0.g:
    com.esotericsoftware.kryo.io.ByteBufferInput input -> b
    com.esotericsoftware.kryo.Kryo kryo -> a
    com.esotericsoftware.kryo.io.ByteBufferOutput output -> c
    void write(com.esotericsoftware.kryonet.Connection,java.nio.ByteBuffer,java.lang.Object) -> a
    int readLength(java.nio.ByteBuffer) -> b
    java.lang.Object read(com.esotericsoftware.kryonet.Connection,java.nio.ByteBuffer) -> c
    int getLengthLength() -> d
    void writeLength(java.nio.ByteBuffer,int) -> e
    com.esotericsoftware.kryo.Kryo getKryo() -> f
com.esotericsoftware.kryonet.Listener -> r0.h:
    void connected(com.esotericsoftware.kryonet.Connection) -> a
    void disconnected(com.esotericsoftware.kryonet.Connection) -> b
    void idle(com.esotericsoftware.kryonet.Connection) -> c
    void received(com.esotericsoftware.kryonet.Connection,java.lang.Object) -> d
com.esotericsoftware.kryonet.Serialization -> r0.i:
    void write(com.esotericsoftware.kryonet.Connection,java.nio.ByteBuffer,java.lang.Object) -> a
    int readLength(java.nio.ByteBuffer) -> b
    java.lang.Object read(com.esotericsoftware.kryonet.Connection,java.nio.ByteBuffer) -> c
    int getLengthLength() -> d
    void writeLength(java.nio.ByteBuffer,int) -> e
com.esotericsoftware.kryonet.TcpConnection -> r0.j:
    long lastWriteTime -> j
    com.esotericsoftware.kryonet.Serialization serialization -> h
    int currentObjectLength -> l
    long lastReadTime -> k
    float idleThreshold -> g
    int timeoutMillis -> f
    java.nio.ByteBuffer writeBuffer -> d
    java.nio.ByteBuffer readBuffer -> c
    int keepAliveMillis -> b
    java.nio.channels.SelectionKey selectionKey -> i
    java.lang.Object writeLock -> m
    boolean bufferPositionFix -> e
    java.nio.channels.SocketChannel socketChannel -> a
    void close() -> a
    void connect(java.nio.channels.Selector,java.net.SocketAddress,int) -> b
    boolean isTimedOut(long) -> c
    boolean needsKeepAlive(long) -> d
    java.lang.Object readObject(com.esotericsoftware.kryonet.Connection) -> e
    int send(com.esotericsoftware.kryonet.Connection,java.lang.Object) -> f
    void writeOperation() -> g
    boolean writeToSocket() -> h
com.esotericsoftware.kryonet.UdpConnection -> r0.k:
    long lastCommunicationTime -> i
    java.net.InetSocketAddress connectedAddress -> a
    java.lang.Object writeLock -> h
    com.esotericsoftware.kryonet.Serialization serialization -> f
    java.nio.channels.DatagramChannel datagramChannel -> b
    java.nio.ByteBuffer writeBuffer -> e
    java.nio.channels.SelectionKey selectionKey -> g
    java.nio.ByteBuffer readBuffer -> d
    int keepAliveMillis -> c
    void close() -> a
    void connect(java.nio.channels.Selector,java.net.InetSocketAddress) -> b
    boolean needsKeepAlive(long) -> c
    java.net.InetSocketAddress readFromAddress() -> d
    java.lang.Object readObject(com.esotericsoftware.kryonet.Connection) -> e
    int send(com.esotericsoftware.kryonet.Connection,java.lang.Object,java.net.SocketAddress) -> f
com.esotericsoftware.minlog.Log -> s0.a:
    com.esotericsoftware.minlog.Log$Logger logger -> f
    boolean TRACE -> e
    boolean ERROR -> a
    boolean WARN -> b
    boolean INFO -> c
    boolean DEBUG -> d
    void debug(java.lang.String,java.lang.String) -> a
    void debug(java.lang.String,java.lang.String,java.lang.Throwable) -> b
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> c
    void info(java.lang.String) -> d
    void info(java.lang.String,java.lang.String) -> e
    void trace(java.lang.String,java.lang.String) -> f
    void trace(java.lang.String,java.lang.String,java.lang.Throwable) -> g
com.esotericsoftware.minlog.Log$Logger -> s0.a$a:
    long firstLogTime -> a
    void log(int,java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void print(java.lang.String) -> b
com.esotericsoftware.reflectasm.AccessClassLoader -> t0.a:
    com.esotericsoftware.reflectasm.AccessClassLoader selfContextAccessClassLoader -> c
    java.lang.ClassLoader selfContextParentClassLoader -> b
    java.util.WeakHashMap accessClassLoaders -> a
    java.lang.Class defineClass(java.lang.String,byte[]) -> a
    com.esotericsoftware.reflectasm.AccessClassLoader get(java.lang.Class) -> b
    java.lang.ClassLoader getParentClassLoader(java.lang.Class) -> c
com.esotericsoftware.reflectasm.ConstructorAccess -> t0.b:
    boolean isNonStaticMemberClass -> a
    com.esotericsoftware.reflectasm.ConstructorAccess get(java.lang.Class) -> a
    void insertConstructor(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter) -> b
    void insertNewInstance(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,java.lang.String) -> c
    void insertNewInstanceInner(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,java.lang.String,java.lang.String) -> d
    java.lang.Object newInstance() -> e
com.esotericsoftware.reflectasm.FieldAccess -> t0.c:
com.esotericsoftware.reflectasm.MethodAccess -> t0.d:
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor -> u0.a:
    int api -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor av -> b
    void visit(java.lang.String,java.lang.Object) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,java.lang.String) -> b
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitArray(java.lang.String) -> c
    void visitEnd() -> d
    void visitEnum(java.lang.String,java.lang.String,java.lang.String) -> e
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter -> u0.b:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter h -> j
    int f -> h
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter g -> i
    boolean c -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector d -> f
    int b -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector e -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter a -> c
    void visit(java.lang.String,java.lang.Object) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,java.lang.String) -> b
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitArray(java.lang.String) -> c
    void visitEnd() -> d
    void visitEnum(java.lang.String,java.lang.String,java.lang.String) -> e
    int a() -> f
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector) -> g
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter[],int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector) -> h
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute -> u0.c:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute a -> c
    java.lang.String type -> a
    int a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,byte[],int,int,int) -> b
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,byte[],int,int,int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector) -> c
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[] getLabels() -> d
    boolean isCodeAttribute() -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute read(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassReader,int,int,char[],int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector write(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,byte[],int,int,int) -> g
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector -> u0.d:
    void a(int) -> b
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector b(int,int) -> c
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putByte(int) -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putByteArray(byte[],int,int) -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putInt(int) -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putLong(long) -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putShort(int) -> h
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector putUTF8(java.lang.String) -> i
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassReader -> u0.e:
    byte[] b -> a
    int[] a -> b
    int header -> e
    int a(int,char[],boolean,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor) -> b
    int a(java.lang.Object[],int,int,char[],com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> c
    java.lang.String a(int,int,char[]) -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute[],java.lang.String,int,int,char[],int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> e
    void a(int,java.lang.String,char[],boolean,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodVisitor) -> f
    void accept(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassVisitor,int) -> g
    void accept(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassVisitor,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute[],int) -> h
    int readByte(int) -> i
    java.lang.String readClass(int,char[]) -> j
    java.lang.Object readConst(int,char[]) -> k
    int readInt(int) -> l
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label readLabel(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> m
    long readLong(int) -> n
    short readShort(int) -> o
    java.lang.String readUTF8(int,char[]) -> p
    int readUnsignedShort(int) -> q
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassVisitor -> u0.f:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassVisitor cv -> b
    int api -> a
    void visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> b
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> c
    void visitEnd() -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldVisitor visitField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.Object) -> e
    void visitInnerClass(java.lang.String,java.lang.String,java.lang.String,int) -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodVisitor visitMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> g
    void visitOuterClass(java.lang.String,java.lang.String,java.lang.String) -> h
    void visitSource(java.lang.String,java.lang.String) -> i
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter -> u0.g:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item[] H -> m
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodWriter E -> J
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter u -> z
    int f -> h
    byte[] a -> N
    int[] p -> u
    boolean J -> L
    int b -> d
    short G -> n
    int z -> E
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item i -> k
    int x -> C
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item[] e -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item g -> i
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldWriter B -> G
    int t -> y
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector A -> F
    int n -> s
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter v -> A
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector y -> D
    boolean L -> M
    int k -> o
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassReader M -> c
    java.lang.String I -> q
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector r -> w
    int c -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item j -> l
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item h -> j
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodWriter D -> I
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute w -> B
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldWriter C -> H
    int s -> x
    int q -> v
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector d -> f
    int o -> t
    int m -> r
    int l -> p
    void b(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item) -> A
    int c(java.lang.String) -> B
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item c(java.lang.String) -> C
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item c(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item) -> D
    java.lang.String getCommonSuperClass(java.lang.String,java.lang.String) -> E
    int newClass(java.lang.String) -> F
    int newConst(java.lang.Object) -> G
    int newField(java.lang.String,java.lang.String,java.lang.String) -> H
    int newHandle(int,java.lang.String,java.lang.String,java.lang.String) -> I
    int newMethod(java.lang.String,java.lang.String,java.lang.String,boolean) -> J
    int newNameType(java.lang.String,java.lang.String) -> K
    int newUTF8(java.lang.String) -> L
    byte[] toByteArray() -> M
    void visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> b
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> c
    void visitEnd() -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldVisitor visitField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.Object) -> e
    void visitInnerClass(java.lang.String,java.lang.String,java.lang.String,int) -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodVisitor visitMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[]) -> g
    void visitOuterClass(java.lang.String,java.lang.String,java.lang.String) -> h
    void visitSource(java.lang.String,java.lang.String) -> i
    int a(int,int) -> j
    int a(java.lang.String,int) -> k
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(double) -> l
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(float) -> m
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(int) -> n
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(int,java.lang.String,java.lang.String,java.lang.String) -> o
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(long) -> p
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.Object) -> q
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.String) -> r
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.String,java.lang.String) -> s
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.String,java.lang.String,java.lang.String) -> t
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.String,java.lang.String,java.lang.String,boolean) -> u
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(java.lang.String,java.lang.String,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handle,java.lang.Object[]) -> v
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item) -> w
    void a(int,int,int) -> x
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item b(java.lang.String) -> y
    void b(int,int,int) -> z
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Edge -> u0.h:
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldVisitor -> u0.i:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldVisitor fv -> b
    int api -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> a
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> b
    void visitEnd() -> c
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.FieldWriter -> u0.j:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter i -> j
    int g -> h
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter h -> i
    int e -> f
    int f -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute j -> k
    int c -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter b -> c
    int d -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> a
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> b
    void visitEnd() -> c
    int a() -> d
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector) -> e
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Frame -> u0.k:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label b -> a
    int[] i -> h
    int[] a -> i
    int[] c -> b
    int[] d -> c
    int[] e -> d
    int[] f -> e
    int g -> f
    int h -> g
    int a(int) -> b
    int a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,int) -> c
    void a(int,int) -> d
    void a(int,int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item) -> e
    void a(java.lang.String) -> f
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type[],int) -> g
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,java.lang.String) -> h
    boolean a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,int,int[],int) -> i
    boolean a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Frame,int) -> j
    int b(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter,java.lang.String) -> k
    void b(int) -> l
    void c(int) -> m
    void d(int) -> n
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handle -> u0.l:
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handler -> u0.m:
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item -> u0.n:
    java.lang.String i -> g
    java.lang.String h -> f
    int j -> h
    java.lang.String g -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item k -> i
    void a(float) -> b
    void a(int) -> c
    void a(int,int) -> d
    void a(int,java.lang.String,java.lang.String,java.lang.String) -> e
    void a(long) -> f
    void a(java.lang.String,java.lang.String,int) -> g
    boolean a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Item) -> h
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label -> u0.o:
    void a(int,int) -> b
    void a(long,int) -> c
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodWriter,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector,int,boolean) -> d
    boolean a(long) -> e
    boolean a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> f
    boolean a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodWriter,int,byte[]) -> g
    void b(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,long,int) -> h
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodVisitor -> u0.p:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodVisitor mv -> b
    int api -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotationDefault() -> b
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> c
    void visitCode() -> d
    void visitEnd() -> e
    void visitFieldInsn(int,java.lang.String,java.lang.String,java.lang.String) -> f
    void visitFrame(int,int,java.lang.Object[],int,java.lang.Object[]) -> g
    void visitIincInsn(int,int) -> h
    void visitInsn(int) -> i
    void visitIntInsn(int,int) -> j
    void visitInvokeDynamicInsn(java.lang.String,java.lang.String,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handle,java.lang.Object[]) -> k
    void visitJumpInsn(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> l
    void visitLabel(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> m
    void visitLdcInsn(java.lang.Object) -> n
    void visitLineNumber(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> o
    void visitLocalVariable(java.lang.String,java.lang.String,java.lang.String,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,int) -> p
    void visitLookupSwitchInsn(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,int[],com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> q
    void visitMaxs(int,int) -> r
    void visitMethodInsn(int,java.lang.String,java.lang.String,java.lang.String) -> s
    void visitMultiANewArrayInsn(java.lang.String,int) -> t
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitParameterAnnotation(int,java.lang.String,boolean) -> u
    void visitTableSwitchInsn(int,int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> v
    void visitTryCatchBlock(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,java.lang.String) -> w
    void visitTypeInsn(int,java.lang.String) -> x
    void visitVarInsn(int,int) -> y
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.MethodWriter -> u0.q:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label N -> Q
    boolean K -> N
    int L -> O
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label P -> S
    java.lang.String g -> h
    int i -> j
    int H -> K
    int F -> I
    int e -> f
    int D -> G
    int c -> d
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ClassWriter b -> c
    int[] x -> A
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter[] p -> q
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector r -> t
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter m -> n
    int[] z -> C
    int T -> w
    int Q -> T
    int s -> u
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector E -> H
    int[] k -> l
    int M -> P
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handler C -> F
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute J -> M
    java.lang.String f -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector l -> m
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute q -> s
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label O -> R
    int j -> k
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector G -> J
    int h -> i
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector I -> L
    int A -> D
    int d -> e
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter[] o -> p
    int y -> B
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationWriter n -> o
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handler B -> E
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector v -> y
    int w -> z
    int u -> x
    int t -> v
    int R -> U
    int S -> r
    int a(byte[],int) -> A
    int a(int[],int[],int,int) -> B
    void a(int,int) -> C
    void a(int,int,int) -> D
    void a(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> E
    void a(java.lang.Object) -> F
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.ByteVector) -> G
    void a(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> H
    void a(byte[],int,int) -> I
    void a(int[],int[],com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> J
    short b(byte[],int) -> K
    void b() -> L
    void b(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Frame) -> M
    int c(byte[],int) -> N
    void c() -> O
    void d() -> P
    void e() -> Q
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotation(java.lang.String,boolean) -> a
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitAnnotationDefault() -> b
    void visitAttribute(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Attribute) -> c
    void visitCode() -> d
    void visitEnd() -> e
    void visitFieldInsn(int,java.lang.String,java.lang.String,java.lang.String) -> f
    void visitFrame(int,int,java.lang.Object[],int,java.lang.Object[]) -> g
    void visitIincInsn(int,int) -> h
    void visitInsn(int) -> i
    void visitIntInsn(int,int) -> j
    void visitInvokeDynamicInsn(java.lang.String,java.lang.String,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Handle,java.lang.Object[]) -> k
    void visitJumpInsn(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> l
    void visitLabel(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> m
    void visitLdcInsn(java.lang.Object) -> n
    void visitLineNumber(int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label) -> o
    void visitLocalVariable(java.lang.String,java.lang.String,java.lang.String,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,int) -> p
    void visitLookupSwitchInsn(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,int[],com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> q
    void visitMaxs(int,int) -> r
    void visitMethodInsn(int,java.lang.String,java.lang.String,java.lang.String) -> s
    void visitMultiANewArrayInsn(java.lang.String,int) -> t
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.AnnotationVisitor visitParameterAnnotation(int,java.lang.String,boolean) -> u
    void visitTableSwitchInsn(int,int,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label[]) -> v
    void visitTryCatchBlock(com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Label,java.lang.String) -> w
    void visitTypeInsn(int,java.lang.String) -> x
    void visitVarInsn(int,int) -> y
    int a() -> z
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Opcodes -> u0.r:
    java.lang.Integer FLOAT -> c
    java.lang.Integer DOUBLE -> d
    java.lang.Integer LONG -> e
    java.lang.Integer NULL -> f
    java.lang.Integer UNINITIALIZED_THIS -> g
    java.lang.Integer TOP -> a
    java.lang.Integer INTEGER -> b
com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type -> u0.s:
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type INT_TYPE -> j
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type FLOAT_TYPE -> k
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type BYTE_TYPE -> h
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type SHORT_TYPE -> i
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type LONG_TYPE -> l
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type DOUBLE_TYPE -> m
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type BOOLEAN_TYPE -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type CHAR_TYPE -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type VOID_TYPE -> e
    void a(java.lang.StringBuffer) -> b
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type[] getArgumentTypes(java.lang.String) -> c
    int getArgumentsAndReturnSizes(java.lang.String) -> d
    java.lang.String getDescriptor() -> e
    java.lang.String getInternalName() -> f
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type getMethodType(java.lang.String) -> g
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type getObjectType(java.lang.String) -> h
    int getSort() -> i
    com.esotericsoftware.reflectasm.shaded.org.objectweb.asm.Type getType(java.lang.String) -> j
com.mygdx.tanks2d.Assets.AssetsManagerGame -> w0.a:
    com.badlogic.gdx.assets.AssetManager assetManager -> b
    java.util.HashMap assets -> a
    java.lang.Object get(java.lang.String) -> a
    java.lang.Object get(java.lang.String,java.lang.Class) -> b
    com.badlogic.gdx.assets.AssetManager loadAllAsseGame() -> c
    com.badlogic.gdx.assets.AssetManager loadAllAssetMenu() -> d
    void loadedAseets() -> e
com.mygdx.tanks2d.AudioEngine.AudioEngine -> x0.a:
    com.badlogic.gdx.audio.Sound sound -> c
    com.badlogic.gdx.audio.Sound track -> d
    com.badlogic.gdx.math.Vector2 tempV -> t
    com.badlogic.gdx.audio.Sound pip1 -> a
    boolean SondOn -> p
    java.lang.Long idTrack -> m
    java.lang.Long idTower -> n
    com.badlogic.gdx.audio.Sound redy_for_action -> k
    com.badlogic.gdx.audio.Sound pip -> l
    com.badlogic.gdx.audio.Sound win -> i
    com.badlogic.gdx.audio.Sound music_pause -> j
    com.badlogic.gdx.audio.Sound fight -> g
    boolean MusicOn -> q
    com.badlogic.gdx.audio.Sound loose -> h
    boolean Vibration -> r
    com.badlogic.gdx.audio.Sound tower -> e
    com.badlogic.gdx.audio.Sound explosion -> f
    com.mygdx.tanks2d.MainGame mainGaming -> b
    long pause_music_id -> s
    float timer_towr_ratation -> o
    void Vibration(float) -> a
    void Vibration(int) -> b
    float countVolmeDistantion(float,float,float,float) -> c
    boolean isPause() -> d
    void playMusicPaseMenu() -> e
    void pleySoundKickExplosion(float,float,float,float) -> f
    void pleySoundKickStick(float,float,float,float) -> g
    void pleySoundOfTower() -> h
    void pleySoundOfTracks() -> i
    void pley_fight_ad_sound() -> j
    void pley_lose_ad_sound() -> k
    void pley_pip() -> l
    void pley_win_ad_sound() -> m
    void rady_for_action() -> n
    void stopMusicPaseMenu() -> o
    void stopSoundOfTower() -> p
    void stopSoundOfTracks() -> q
    void update_volme_pause(float) -> r
com.mygdx.tanks2d.CameraGame -> v0.a:
    com.badlogic.gdx.utils.viewport.FillViewport viewport -> c
    int wl -> h
    com.mygdx.tanks2d.Units.Tanks.OpponentsTanks targetCamera -> a
    int dw -> i
    com.badlogic.gdx.graphics.OrthographicCamera camera -> b
    int hl -> g
    int sizeMap -> e
    boolean floatCamera -> d
    com.badlogic.gdx.math.Vector2 targetPoint -> f
    void createNewTargetDeathRhim(com.mygdx.tanks2d.Units.Tanks.OpponentsTanks) -> a
    void deathStatus(com.mygdx.tanks2d.Units.Tanks.Tank) -> b
    void fixBounds() -> c
    com.badlogic.gdx.graphics.OrthographicCamera getCamera() -> d
    com.badlogic.gdx.math.Vector3 getCameraPosition() -> e
    com.badlogic.gdx.utils.viewport.FillViewport getViewport() -> f
    void integrationCamera() -> g
    void interatorCamera() -> h
    void jampCameraToPoint(float,float) -> i
    void moveFloatCameraToPoint(float,float,float) -> j
    void setTargetCamera(com.mygdx.tanks2d.Units.Tanks.OpponentsTanks) -> k
com.mygdx.tanks2d.ClientNetWork.ClientThread -> y0.a:
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient voiceChatClient -> b
    com.esotericsoftware.kryonet.Client client -> a
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient getVoiceChatClient() -> a
com.mygdx.tanks2d.ClientNetWork.Heading_type -> y0.b:
    java.util.HashMap domen -> a
    java.lang.String getDomenTip(int) -> a
com.mygdx.tanks2d.ClientNetWork.MainClient -> y0.c:
    java.util.HashMap frameUpdates -> h
    float coonection -> j
    com.esotericsoftware.kryonet.Client client -> a
    com.mygdx.tanks2d.MainGame mg -> c
    com.mygdx.tanks2d.ClientNetWork.NetworkPacketStock networkPacketStock -> f
    boolean key_coonection -> k
    int myIdConnect -> d
    com.mygdx.tanks2d.ClientNetWork.ClientThread clientThread -> i
    boolean onLine -> b
    java.util.TreeMap otherPlayer -> g
    com.mygdx.tanks2d.ClientNetWork.RouterSM routerSM -> e
    float access$002(float) -> a
    boolean access$102(boolean) -> b
    boolean checkConnect(int) -> c
    com.esotericsoftware.kryonet.Client getClient() -> d
    com.mygdx.tanks2d.ClientNetWork.NetworkPacketStock getNetworkPacketStock() -> e
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient getVoiceChatClient() -> f
    void reconectClienNewThred() -> g
    void router(java.lang.Object) -> h
    void setMyIdConnect(int) -> i
    void upDateClient() -> j
com.mygdx.tanks2d.ClientNetWork.MainClient$1 -> y0.c$a:
    com.mygdx.tanks2d.ClientNetWork.MainClient this$0 -> a
    void connected(com.esotericsoftware.kryonet.Connection) -> a
    void disconnected(com.esotericsoftware.kryonet.Connection) -> b
    void received(com.esotericsoftware.kryonet.Connection,java.lang.Object) -> d
com.mygdx.tanks2d.ClientNetWork.MainClient$2 -> y0.c$b:
    com.mygdx.tanks2d.ClientNetWork.MainClient this$0 -> a
com.mygdx.tanks2d.ClientNetWork.Network -> y0.d:
    void register(com.esotericsoftware.kryonet.EndPoint) -> a
com.mygdx.tanks2d.ClientNetWork.Network$Frag -> y0.d$a:
com.mygdx.tanks2d.ClientNetWork.Network$GivePlayerParameters -> y0.d$b:
    java.lang.String nik -> b
    int nomerPlayer -> a
com.mygdx.tanks2d.ClientNetWork.Network$PleyerPosition -> y0.d$c:
    float roy_tower -> c
    float yp -> b
    float xp -> a
com.mygdx.tanks2d.ClientNetWork.Network$PleyerPositionNom -> y0.d$d:
    float roy_tower -> d
    float yp -> c
    float xp -> b
    int nom -> a
com.mygdx.tanks2d.ClientNetWork.Network$StockMessInClient -> y0.d$e:
com.mygdx.tanks2d.ClientNetWork.Network$StockMessOut -> y0.d$f:
    java.lang.String textM -> f
    float p4 -> e
    float p3 -> d
    float p2 -> c
    float p1 -> b
    int tip -> a
com.mygdx.tanks2d.ClientNetWork.NetworkPacketStock -> y0.e:
    com.esotericsoftware.kryonet.Client client -> a
    boolean required_to_send_tooken -> b
    void sendMuCoordinat(float,float,int) -> a
    void send_package_to_server(int,float,float,float,float,java.lang.String) -> b
    void toSendButtonStartClick() -> c
    void toSendMyParPlayer(int) -> d
    void toSendMyShot(float,float,float) -> e
    void toSendMyTokken(int) -> f
com.mygdx.tanks2d.ClientNetWork.RouterSM -> y0.f:
    com.badlogic.gdx.math.Vector2 position -> c
    com.badlogic.gdx.math.Vector2 positionTemp -> d
    com.badlogic.gdx.math.Vector2 velocity -> b
    com.mygdx.tanks2d.MainGame mainGame -> a
    java.lang.String map_math -> e
    void routeSM(com.mygdx.tanks2d.ClientNetWork.Network$StockMessOut) -> a
    void saveParametrsMyTank(com.mygdx.tanks2d.ClientNetWork.Network$StockMessOut) -> b
com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient -> z0.a:
    com.badlogic.gdx.audio.AudioRecorder recorder -> a
    com.badlogic.gdx.audio.AudioDevice player -> b
    float timer -> f
    float sendRate -> d
    boolean ready -> g
    int sampleRate -> c
    short[] data -> e
    com.badlogic.gdx.audio.AudioRecorder access$200(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient) -> A
    void access$300(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient) -> E
    boolean access$402(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient,boolean) -> G
    void addReceiver(com.esotericsoftware.kryonet.Client) -> Q
    void createPlayer() -> W
    void createRecorder() -> X
    int getSampleRate() -> Y
    float getSendRate() -> Z
    void dispose() -> a
    void processAudio(short[],com.esotericsoftware.kryonet.Connection,com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceNetData) -> a0
    void registerNetObjects(com.esotericsoftware.kryo.Kryo) -> b0
    void sendVoice(com.esotericsoftware.kryonet.Client,float) -> c0
    com.badlogic.gdx.audio.AudioDevice access$000(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient) -> k
    short[] access$100(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient) -> o
    short[] access$102(com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient,short[]) -> p
com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient$1 -> z0.a$a:
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient this$0 -> a
    void received(com.esotericsoftware.kryonet.Connection,java.lang.Object) -> d
com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient$2 -> z0.a$b:
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient this$0 -> b
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceNetData val$message -> a
com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient$4 -> z0.a$c:
    com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceChatClient this$0 -> b
    com.esotericsoftware.kryonet.Client val$client -> a
com.mygdx.tanks2d.ClientNetWork.VoiceChat.VoiceNetData -> z0.b:
    short[] data -> a
    short[] getData() -> a
com.mygdx.tanks2d.InputProcessor.InputProcessorDesktop -> a1.a:
    com.badlogic.gdx.math.Vector2 velocity -> b
    com.mygdx.tanks2d.Screens.GamePlayScreen gps -> a
    boolean mouseMoved(int,int) -> A
    boolean touchUp(int,int,int,int) -> E
    boolean scrolled(float,float) -> G
    boolean touchDragged(int,int,int) -> Q
    boolean keyUp(int) -> W
    boolean keyTyped(char) -> k
    boolean keyDown(int) -> o
    boolean touchDown(int,int,int,int) -> p
com.mygdx.tanks2d.Locations.Collision.BoxCollision -> c1.a:
    com.badlogic.gdx.math.Vector2 center -> c
    com.badlogic.gdx.math.Vector2 lb -> a
    com.badlogic.gdx.math.Vector2 ru -> b
    void getCenter() -> a
    com.badlogic.gdx.math.Vector2 getLb() -> b
    com.badlogic.gdx.math.Vector2 getRu() -> c
    boolean isCollisionTank(com.badlogic.gdx.math.Vector2) -> d
com.mygdx.tanks2d.Locations.Collision.CircleCollision -> c1.b:
    com.badlogic.gdx.math.Vector2 circule -> a
    float getRadiusKV -> c
    float radius -> b
    boolean isCollisionCircle(com.badlogic.gdx.math.Vector2) -> a
com.mygdx.tanks2d.Locations.Collision.MainCollision -> c1.c:
    com.badlogic.gdx.math.Vector2 tempVector -> b
    com.mygdx.tanks2d.Screens.GamePlayScreen gsp -> a
    java.util.ArrayList circle -> d
    java.util.ArrayList box -> c
    void addCircleeMapObject(com.badlogic.gdx.math.Vector2,float) -> a
    void addRectangleMapObject(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> b
    com.badlogic.gdx.math.Vector2 isCircleCircle(com.badlogic.gdx.math.Vector2) -> c
    com.badlogic.gdx.math.Vector2 isCollisionsRectangle(com.badlogic.gdx.math.Vector2) -> d
    void isCollisionsRectangleReturnPosition(com.badlogic.gdx.math.Vector2) -> e
com.mygdx.tanks2d.Locations.Crater -> b1.a:
com.mygdx.tanks2d.Locations.GameSpace -> b1.b:
    com.badlogic.gdx.maps.tiled.TiledMap map -> e
    int WITH_LOCATION -> h
    int HEIHT_LOCATION -> i
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer decorations -> k
    com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer rendererMap -> f
    com.badlogic.gdx.maps.tiled.TiledMapTileLayer ground -> l
    com.badlogic.gdx.math.Vector2 rasp1 -> c
    com.badlogic.gdx.math.Vector2 rasp2 -> d
    com.mygdx.tanks2d.Locations.Radspurens radspurens -> g
    com.badlogic.gdx.maps.MapLayer obstacles -> j
    com.mygdx.tanks2d.Screens.GamePlayScreen gps -> a
    com.mygdx.tanks2d.Locations.Collision.MainCollision mainCollision -> m
    com.mygdx.tanks2d.Locations.MapsList mapsList -> b
    void addSled(float,float,float) -> a
    boolean checkMapBordersReturnSpaceTank(com.badlogic.gdx.math.Vector2) -> b
    void clear_map_particel() -> c
    com.mygdx.tanks2d.Screens.GamePlayScreen getGps() -> d
    com.mygdx.tanks2d.Locations.Collision.MainCollision getMainCollision() -> e
    com.mygdx.tanks2d.Locations.Radspurens getRadspurens() -> f
    com.badlogic.gdx.math.Vector2 getRasp1() -> g
    com.badlogic.gdx.math.Vector2 getRasp2() -> h
    int getSizeLocationPixel() -> i
    boolean inPointLocation(float,float) -> j
    void loadMap() -> k
    void renderSpace(com.badlogic.gdx.graphics.OrthographicCamera) -> l
    void setMapDesetrt(java.lang.String) -> m
com.mygdx.tanks2d.Locations.MapsList -> b1.c:
    java.util.ArrayList mapsList -> a
com.mygdx.tanks2d.Locations.RadspurenTank -> b1.d:
    float timer -> d
    boolean life -> e
    float aligbDeg -> c
    float yp -> b
    float xp -> a
com.mygdx.tanks2d.Locations.Radspurens -> b1.e:
    com.badlogic.gdx.graphics.Texture crater -> d
    com.badlogic.gdx.graphics.Texture sled -> c
    java.util.ArrayDeque listRadspurens -> a
    java.util.ArrayDeque listCrater -> b
    void addCrater(float,float,float) -> a
    void addRadspurenTank(float,float,float) -> b
    void clearCrater() -> c
    void clearRadspurens() -> d
    void randerCrater(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> e
    void randerRadspurens(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> f
com.mygdx.tanks2d.MainGame -> v0.b:
    byte flagChangeScreen -> j
    com.mygdx.tanks2d.AudioEngine.AudioEngine audioEngine -> b
    float hu -> i
    int status -> m
    float hb -> h
    java.lang.String nik_name -> k
    com.mygdx.tanks2d.Assets.AssetsManagerGame assetsManagerGame -> c
    boolean ANDROID -> l
    com.badlogic.gdx.Screen mainMenu -> g
    com.mygdx.tanks2d.ClientNetWork.MainClient mainClient -> d
    com.mygdx.tanks2d.Screens.GamePlayScreen gamePlayScreen -> e
    com.mygdx.tanks2d.Screens.PauseScreen.PauseScreen pauseScreen -> f
    void create() -> e
    float convert_percentage_pixels(float,boolean) -> h
    void count_the_edges_of_the_screen() -> i
    com.mygdx.tanks2d.Assets.AssetsManagerGame getAMG() -> j
    com.mygdx.tanks2d.Screens.GamePlayScreen getGamePlayScreen() -> k
    com.mygdx.tanks2d.ClientNetWork.MainClient getMainClient() -> l
    float get_percentage_of_proportions(float,float) -> m
    void goGameForPause() -> n
    void goMenuForPause() -> o
    boolean isMainMenuScreen() -> p
    boolean isPause() -> q
    void setFlagChangeScreen(byte) -> r
    void startGameMPley() -> s
    void startGameSPley() -> t
    void startPauseScreen() -> u
    void updateClien() -> v
com.mygdx.tanks2d.ParticleEffect.Explosion_Death -> d1.a:
    com.badlogic.gdx.math.Vector2 position -> a
    float kefm -> d
    float time_life -> b
    int nom_texture -> c
    float getKefm() -> a
    java.lang.String getNameTextureRegion() -> b
    com.badlogic.gdx.math.Vector2 getPosition() -> c
    float getTime_life() -> d
    boolean isLife() -> e
    void setParameters(float,float) -> f
    void setParameters(float,float,float) -> g
    void update() -> h
com.mygdx.tanks2d.ParticleEffect.Garbage -> d1.b:
    com.badlogic.gdx.math.Vector2 pos -> a
    com.badlogic.gdx.math.Vector2 velocity -> b
    float temperature -> e
    float rot -> d
    float timeLife -> c
    com.badlogic.gdx.math.Vector2 getPos() -> a
    boolean isLife() -> b
    void setParametors(float,float) -> c
    void setParametors(float,float,float,float) -> d
    void upDate() -> e
com.mygdx.tanks2d.ParticleEffect.ParticleCustum -> d1.c:
    java.util.ArrayDeque smoke_elements -> h
    java.util.ArrayDeque pasricalDeathSmokes -> i
    java.util.ArrayDeque flying_stereo_elements_bases -> j
    java.util.ArrayDeque point_of_fires -> k
    com.badlogic.gdx.math.Vector2 temp_V -> l
    com.mygdx.tanks2d.Screens.GamePlayScreen gps -> t
    com.badlogic.gdx.graphics.g2d.SpriteBatch sb -> m
    java.util.ArrayDeque shardsArr -> d
    com.badlogic.gdx.graphics.Texture f -> o
    com.badlogic.gdx.graphics.g2d.TextureAtlas textureAtlasDeathExplosion -> r
    java.util.ArrayDeque explosion_Death -> e
    com.badlogic.gdx.graphics.Texture t -> n
    java.util.ArrayDeque explosion_Death_little -> f
    java.util.ArrayDeque falling_elements -> g
    com.badlogic.gdx.graphics.Texture explosion_ring -> s
    java.util.ArrayDeque particleDeque -> a
    java.util.ArrayDeque pasricalExplosions -> b
    com.badlogic.gdx.graphics.Texture shardsTex -> q
    java.util.ArrayDeque pasricalExplosionsBigParam -> c
    com.badlogic.gdx.graphics.Texture iron -> p
    void addAnimationDeath(float,float) -> a
    void addParticalsSmokeOneBullet(float,float) -> b
    void addParticalsSmokeStereo(float,float,float) -> c
    void addPasricalDeath(float,float) -> d
    void addPasricalDeath_little(float,float,float) -> e
    void addShares(float,float) -> f
    void addShares(float,float,float,float) -> g
    void add_Point_of_fire(float,float) -> h
    void add_flying_stereo_elements_bases(float,float,float,float,float,com.badlogic.gdx.graphics.Texture,float,float,float,float) -> i
    boolean checkViseble(float,float) -> j
    void generatorSmoke(float,float,float) -> k
    com.badlogic.gdx.graphics.Texture getT() -> l
    void randerGarbage(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> m
    void rander_explosion_Death() -> n
    void rander_explosion_Death_little() -> o
    void rander_flying_stereo_elements_bases() -> p
    void rander_particleDeque() -> q
    void rander_point_of_fires(float) -> r
    void rander_smoke_death(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> s
    void render(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> t
com.mygdx.tanks2d.ParticleEffect.ParticleSmoke -> d1.d:
    com.badlogic.gdx.math.Vector2 velocity -> d
    com.badlogic.gdx.math.Vector2 position -> a
    boolean live -> i
    float scalingKef -> g
    com.badlogic.gdx.graphics.Color color -> h
    float time_life -> f
    float rotate -> e
    float scale -> c
    float rotation -> b
    com.badlogic.gdx.graphics.Color getColor() -> a
    com.badlogic.gdx.math.Vector2 getPosition() -> b
    float getRotation() -> c
    float getScale() -> d
    float getTime_life() -> e
    boolean isLife() -> f
    void setAlpha(float) -> g
    void setParameters(float,float,float,float,float,float,float,float,float,float,float,float,float) -> h
    void update() -> i
com.mygdx.tanks2d.ParticleEffect.PasricalExplosion -> d1.e:
    com.badlogic.gdx.math.Vector2 position -> a
    float rot -> e
    float time_life -> d
    float baseScale -> c
    float startTimeMax -> b
com.mygdx.tanks2d.ParticleEffect.PasricalExplosionBigParameter -> d1.f:
    com.badlogic.gdx.math.Vector2 position -> a
    float baseTimeLife -> g
    float alpha -> e
    float rot -> d
    int par -> f
    float time_life -> c
    float baseScale -> b
com.mygdx.tanks2d.ParticleEffect.Shard -> d1.g:
com.mygdx.tanks2d.ParticleEffect.StereoSmoke.Falling_element -> e1.a:
    com.badlogic.gdx.graphics.Color color -> e
    float hi -> i
    float wi -> h
    com.badlogic.gdx.math.Vector3 position -> a
    float dy -> g
    float dx -> f
    float align -> d
    float speed -> c
    com.badlogic.gdx.graphics.Texture texture -> b
    boolean checkLimet() -> a
    void rander(float,com.badlogic.gdx.graphics.Camera,com.badlogic.gdx.graphics.g2d.SpriteBatch) -> b
    void update(float,com.badlogic.gdx.graphics.Camera) -> c
com.mygdx.tanks2d.ParticleEffect.StereoSmoke.Flying_stereo_elements_base -> e1.b:
    float deltaCamera -> j
    com.badlogic.gdx.graphics.Color color -> f
    float scale -> i
    float dy -> h
    com.badlogic.gdx.math.Vector3 position -> a
    float dx -> g
    float align -> e
    com.badlogic.gdx.graphics.g2d.SpriteBatch spriteBatch -> c
    float speed -> d
    com.badlogic.gdx.graphics.Texture texture -> b
    void add(float,float,float,float,float,com.badlogic.gdx.graphics.Texture,float,float,float,float) -> a
    boolean checkLimet() -> b
    void rander(float,com.badlogic.gdx.graphics.Camera) -> c
    void update(float,com.badlogic.gdx.graphics.Camera) -> d
com.mygdx.tanks2d.ParticleEffect.StereoSmoke.PasricalDeathSmoke -> e1.c:
    boolean checkLimet() -> a
    void update(float,com.badlogic.gdx.graphics.Camera) -> c
com.mygdx.tanks2d.ParticleEffect.StereoSmoke.Point_of_fire -> e1.d:
    com.mygdx.tanks2d.ParticleEffect.ParticleCustum pc -> f
    com.badlogic.gdx.graphics.Texture tex -> e
    float y -> d
    float x -> c
    float time_life -> b
    float lifetime_initial -> a
    void generateSmoke() -> a
    boolean isLive() -> b
    void setParametors(float,float,float) -> c
    void update(float) -> d
com.mygdx.tanks2d.ParticleEffect.StereoSmoke.Smoke_element -> e1.e:
    void update(float,com.badlogic.gdx.graphics.Camera) -> c
com.mygdx.tanks2d.Screens.Controll.Banner -> g1.a:
    com.badlogic.gdx.graphics.Texture failed -> g
    com.badlogic.gdx.graphics.Texture victory -> f
    com.badlogic.gdx.graphics.Texture feature -> e
    com.badlogic.gdx.graphics.Texture beck_graund -> i
    com.badlogic.gdx.graphics.Texture temp_texture -> h
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> d
    com.mygdx.tanks2d.AudioEngine.AudioEngine ae -> j
    float timeLife -> a
    java.util.ArrayList q -> c
    boolean flag_sound -> b
    void addBaner(int) -> a
    void delBanner() -> b
    boolean isWorking() -> c
    void rander(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> d
    void update() -> e
com.mygdx.tanks2d.Screens.Controll.Controller -> g1.b:
    com.badlogic.gdx.scenes.scene2d.ui.Label score_red -> q
    com.badlogic.gdx.scenes.scene2d.ui.Label timer -> u
    com.badlogic.gdx.graphics.Texture feature -> z
    boolean finalAd -> J
    com.badlogic.gdx.scenes.scene2d.ui.Label live_score_blue -> s
    float fr -> F
    com.badlogic.gdx.graphics.Texture track -> x
    com.badlogic.gdx.math.Vector2 temp_Point -> j
    com.badlogic.gdx.graphics.Texture failed -> B
    com.badlogic.gdx.scenes.scene2d.ui.Image pointStick -> o
    com.badlogic.gdx.scenes.scene2d.ui.Image attacButton -> m
    com.badlogic.gdx.scenes.scene2d.ui.Image changingGoal -> k
    boolean contollerOn -> E
    boolean attackButon -> f
    com.badlogic.gdx.graphics.OrthographicCamera cam -> d
    boolean chance -> h
    boolean buttonChangingOpponent -> C
    com.badlogic.gdx.scenes.scene2d.ui.Label live_score_red -> r
    com.badlogic.gdx.scenes.scene2d.ui.Label labelHP -> p
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> v
    float time_in_game -> I
    float fb -> G
    com.badlogic.gdx.scenes.scene2d.Stage stage -> c
    com.badlogic.gdx.graphics.Texture fith -> y
    com.badlogic.gdx.scenes.scene2d.ui.Label my_frag -> t
    com.badlogic.gdx.math.Vector2 distance -> i
    int frag -> D
    com.badlogic.gdx.math.Vector2 directionMovement -> H
    com.mygdx.tanks2d.Screens.GamePlayScreen gamePlayScreen -> w
    com.badlogic.gdx.graphics.Texture victory -> A
    com.badlogic.gdx.scenes.scene2d.ui.Image voiceButtonImg -> n
    com.badlogic.gdx.scenes.scene2d.ui.Image stick -> l
    com.badlogic.gdx.utils.viewport.Viewport viewport -> b
    com.mygdx.tanks2d.Screens.Controll.Banner banner -> a
    boolean inTuchMove -> e
    boolean voiceButton -> g
    void setFr(float) -> A
    void setHPHeroTank(int) -> B
    void setLive_score_blue(int) -> C
    void setLive_score_red(int) -> D
    void setTime_in_game(float) -> E
    void update() -> F
    void updateCotrollerFinalAd() -> G
    boolean access$002(com.mygdx.tanks2d.Screens.Controll.Controller,boolean) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Image access$100(com.mygdx.tanks2d.Screens.Controll.Controller) -> b
    void access$200(com.mygdx.tanks2d.Screens.Controll.Controller,com.badlogic.gdx.scenes.scene2d.ui.Image) -> c
    com.badlogic.gdx.math.Vector2 access$300(com.mygdx.tanks2d.Screens.Controll.Controller) -> d
    boolean access$402(com.mygdx.tanks2d.Screens.Controll.Controller,boolean) -> e
    boolean access$502(com.mygdx.tanks2d.Screens.Controll.Controller,boolean) -> f
    com.badlogic.gdx.scenes.scene2d.ui.Label access$600(com.mygdx.tanks2d.Screens.Controll.Controller) -> g
    float access$700(com.mygdx.tanks2d.Screens.Controll.Controller) -> h
    boolean access$802(com.mygdx.tanks2d.Screens.Controll.Controller,boolean) -> i
    void addBannerFeiath() -> j
    void addBannerLOUSER() -> k
    void addBannerWiner() -> l
    void addFrag() -> m
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> n
    java.lang.String format_time(int) -> o
    com.badlogic.gdx.math.Vector2 getDirectionMovement() -> p
    boolean isAttackButon() -> q
    boolean isChance() -> r
    boolean isInTuchMove() -> s
    boolean isVoiceButton() -> t
    void randerGUI(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> u
    void resetPoint(com.badlogic.gdx.scenes.scene2d.ui.Image) -> v
    void setButtonChangingOpponent(boolean) -> w
    void setChance(boolean) -> x
    void setContollerOn(boolean) -> y
    void setFb(float) -> z
com.mygdx.tanks2d.Screens.Controll.Controller$1 -> g1.b$a:
    com.mygdx.tanks2d.Screens.Controll.Controller this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.mygdx.tanks2d.Screens.Controll.Controller$2 -> g1.b$b:
    com.mygdx.tanks2d.Screens.Controll.Controller this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.mygdx.tanks2d.Screens.Controll.Controller$3 -> g1.b$c:
    com.mygdx.tanks2d.Screens.Controll.Controller this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.mygdx.tanks2d.Screens.Controll.Controller$4 -> g1.b$d:
    com.mygdx.tanks2d.Screens.Controll.Controller this$0 -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.mygdx.tanks2d.Screens.GamePlayScreen -> f1.a:
    int score_red_command -> n
    com.mygdx.tanks2d.InputProcessor.InputProcessorDesktop inputProcessorPC -> g
    int live_blue_command -> o
    com.mygdx.tanks2d.Locations.GameSpace gameSpace -> e
    int score_blue_command -> m
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> c
    float timeInGame -> d
    com.mygdx.tanks2d.Screens.Controll.Controller controller -> h
    com.mygdx.tanks2d.Units.Tanks.Tank tank -> i
    com.badlogic.gdx.math.Vector2 pos -> j
    com.mygdx.tanks2d.AudioEngine.AudioEngine audioEngine -> f
    com.mygdx.tanks2d.Units.Bullets bullets -> k
    com.mygdx.tanks2d.CameraGame cameraGame -> b
    com.mygdx.tanks2d.MainGame mainGame -> a
    com.mygdx.tanks2d.ParticleEffect.ParticleCustum pc -> l
    int live_red_command -> p
    com.mygdx.tanks2d.Units.Tanks.TanksOther tanksOther -> q
    void update() -> A
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void show() -> e
    void render(float) -> f
    void hide() -> g
    com.mygdx.tanks2d.Assets.AssetsManagerGame getAMG() -> h
    com.mygdx.tanks2d.AudioEngine.AudioEngine getAudioEngine() -> i
    com.badlogic.gdx.graphics.g2d.SpriteBatch getBatch() -> j
    com.mygdx.tanks2d.Units.Bullets getBullets() -> k
    com.mygdx.tanks2d.CameraGame getCameraGame() -> l
    com.mygdx.tanks2d.Screens.Controll.Controller getController() -> m
    com.mygdx.tanks2d.Locations.GameSpace getGameSpace() -> n
    int getLive_blue_command() -> o
    int getLive_red_command() -> p
    com.mygdx.tanks2d.MainGame getMainGame() -> q
    com.mygdx.tanks2d.ParticleEffect.ParticleCustum getPc() -> r
    com.mygdx.tanks2d.Units.Tanks.Tank getTank() -> s
    com.mygdx.tanks2d.Units.Tanks.TanksOther getTanksOther() -> t
    float getTimeInGame() -> u
    void playAnimation(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,int) -> v
    void playExplosion(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> w
    void setLive_blue_command(int) -> x
    void setLive_red_command(int) -> y
    void startFlashForMainTank() -> z
com.mygdx.tanks2d.Screens.MenuScreen -> f1.b:
    boolean startgameSP -> m
    float timerStartGame -> k
    float timeInScreen -> j
    com.badlogic.gdx.scenes.scene2d.ui.TextButton textButton -> q
    boolean startgameMP -> l
    com.mygdx.tanks2d.ClientNetWork.MainClient mainClient -> e
    com.badlogic.gdx.scenes.scene2d.Stage stageMenu -> o
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> b
    com.badlogic.gdx.scenes.scene2d.ui.Label statusConnetct -> n
    boolean button_start_click -> r
    java.lang.String limit -> t
    com.badlogic.gdx.graphics.Texture wallpaper1 -> g
    com.badlogic.gdx.graphics.Texture wallpaper -> f
    com.badlogic.gdx.utils.viewport.StretchViewport viewport -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin skinMenu -> p
    com.badlogic.gdx.graphics.Texture disconnect -> i
    com.badlogic.gdx.graphics.Texture logo -> h
    com.mygdx.tanks2d.MainGame mainGame -> a
    com.badlogic.gdx.graphics.OrthographicCamera camera -> d
    com.badlogic.gdx.utils.FloatArray dummyArray -> s
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void show() -> e
    void render(float) -> f
    void hide() -> g
    boolean access$000(com.mygdx.tanks2d.Screens.MenuScreen) -> h
    boolean access$002(com.mygdx.tanks2d.Screens.MenuScreen,boolean) -> i
    com.mygdx.tanks2d.ClientNetWork.MainClient access$100(com.mygdx.tanks2d.Screens.MenuScreen) -> j
    boolean access$202(com.mygdx.tanks2d.Screens.MenuScreen,boolean) -> k
    void upDateScreen() -> l
com.mygdx.tanks2d.Screens.MenuScreen$1 -> f1.b$a:
    com.mygdx.tanks2d.Screens.MenuScreen this$0 -> d
    com.badlogic.gdx.scenes.scene2d.ui.TextField val$textField -> c
    com.mygdx.tanks2d.MainGame val$mainGame -> b
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.mygdx.tanks2d.Screens.PauseScreen.PauseScreen -> h1.a:
    com.badlogic.gdx.utils.viewport.StretchViewport viewport -> c
    float timeInScreen -> g
    com.badlogic.gdx.graphics.Texture tb -> j
    com.badlogic.gdx.graphics.Texture f_bw -> i
    com.badlogic.gdx.graphics.Texture f -> h
    com.mygdx.tanks2d.ClientNetWork.MainClient mainClient -> e
    com.mygdx.tanks2d.MainGame mainGame -> a
    com.badlogic.gdx.graphics.OrthographicCamera camera -> d
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> b
    com.mygdx.tanks2d.AudioEngine.AudioEngine audioEngine -> f
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void show() -> e
    void render(float) -> f
    void hide() -> g
    float getAlpha() -> h
    float getWith() -> i
    void update() -> j
com.mygdx.tanks2d.Units.BulletPool.Bullet -> j1.a:
    com.badlogic.gdx.math.Vector2 position -> a
    com.badlogic.gdx.math.Vector2 direction -> b
    float timeLife -> e
    int coomand -> d
    int namber -> c
    void fireBullet(float,float,float,float,int,int) -> a
    void reset() -> b
    float getTimeLife() -> c
    void update(float) -> d
com.mygdx.tanks2d.Units.BulletPool.BulletPool -> j1.b:
    java.lang.Object newObject() -> d
    com.mygdx.tanks2d.Units.BulletPool.Bullet newObject() -> g
com.mygdx.tanks2d.Units.Bullets -> i1.a:
    com.mygdx.tanks2d.Units.BulletPool.BulletPool bp -> c
    int MAX_distribution_smoke -> d
    com.badlogic.gdx.utils.Array activeBullets -> b
    com.mygdx.tanks2d.Screens.GamePlayScreen gpl -> e
    com.badlogic.gdx.graphics.Texture img -> a
    void addBullet(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2,int) -> a
    boolean checkingGoingAbroad(float,float) -> b
    void randerBullets(float) -> c
    com.badlogic.gdx.math.Vector2 removeBullet(int) -> d
    void removeBullet(com.mygdx.tanks2d.Units.BulletPool.Bullet) -> e
com.mygdx.tanks2d.Units.NikName -> i1.b:
    java.lang.String genirateTokk() -> a
    java.lang.String getNikName() -> b
    java.lang.String getTokken() -> c
    void setNikName(java.lang.String) -> d
com.mygdx.tanks2d.Units.Tanks.OpponentsTanks -> k1.a:
    float SPEED -> j
    float SPEED_ROTATION -> i
    com.mygdx.tanks2d.Screens.GamePlayScreen gsp -> l
    int hp -> m
    int nomder -> h
    com.badlogic.gdx.math.Vector2 temp_delta -> k
    java.lang.String nikPlayer -> o
    float color -> a
    com.badlogic.gdx.math.Vector2 directionMovementControll -> e
    com.badlogic.gdx.math.Vector2 direction_tower -> f
    com.badlogic.gdx.math.Vector2 position -> c
    com.badlogic.gdx.math.Vector2 direction -> d
    java.lang.Integer command -> n
    boolean move -> b
    com.mygdx.tanks2d.Units.Tanks.TowerRotation towerRotation -> g
    float getColor() -> a
    java.lang.Integer getCommand() -> b
    com.badlogic.gdx.math.Vector2 getDirection() -> c
    com.badlogic.gdx.math.Vector2 getDirection_tower() -> d
    java.lang.String getNikPlayer() -> e
    int getNomder() -> f
    com.badlogic.gdx.math.Vector2 getPosition() -> g
    boolean isCollisionsTanks(com.badlogic.gdx.math.Vector2) -> h
    boolean isLive() -> i
    void setLive(float) -> j
    void setNikPlayer(java.lang.String) -> k
com.mygdx.tanks2d.Units.Tanks.Tank -> k1.b:
    com.badlogic.gdx.math.Vector2 deltaSledVec -> t
    float g -> B
    com.badlogic.gdx.graphics.g2d.SpriteBatch sb -> f
    com.badlogic.gdx.math.Vector2 direction -> c
    com.badlogic.gdx.graphics.Texture img -> g
    com.badlogic.gdx.math.Vector2 DEATH_VECTOR -> D
    com.badlogic.gdx.graphics.Texture imgB2 -> k
    com.badlogic.gdx.graphics.Texture img2 -> i
    float SPEED -> u
    com.badlogic.gdx.graphics.Texture target -> o
    float deltaSled -> s
    com.badlogic.gdx.graphics.Texture body -> m
    float raz -> q
    com.badlogic.gdx.math.Vector2 point_respown_red -> z
    boolean banner_feith -> C
    java.lang.Integer my_Command -> E
    float time_life -> A
    boolean rot -> r
    com.badlogic.gdx.math.Vector2 direction_tower -> e
    com.mygdx.tanks2d.Units.Tanks.TowerRotation tr -> w
    com.badlogic.gdx.math.Vector2 targetCoordinat -> d
    com.badlogic.gdx.math.Vector2 position -> b
    com.badlogic.gdx.graphics.Texture imgB -> j
    float SPEED_ROTATION -> v
    int hp -> x
    com.badlogic.gdx.graphics.Texture img_1 -> h
    com.mygdx.tanks2d.Screens.GamePlayScreen gsp -> a
    com.badlogic.gdx.graphics.Texture towers -> n
    com.badlogic.gdx.math.Vector2 point_respown_blue -> y
    com.badlogic.gdx.graphics.Texture img_1B -> l
    com.badlogic.gdx.graphics.Texture target_guidance -> p
    void tower_sec() -> A
    void upDateHpHud() -> B
    void update(com.badlogic.gdx.math.Vector2,boolean) -> C
    void banner_feith() -> a
    void collisinCircleTrue() -> b
    void collisinOtherTanksTrue() -> c
    void collisinRectangleTrue() -> d
    void flashing_tank() -> e
    int generateCommand() -> f
    void generatorSled() -> g
    void generatorSmoke() -> h
    com.badlogic.gdx.math.Vector2 getDirection_tower() -> i
    com.mygdx.tanks2d.Screens.GamePlayScreen getGsp() -> j
    int getHp() -> k
    java.lang.Integer getMy_Command() -> l
    com.badlogic.gdx.math.Vector2 getPosition() -> m
    void getTargetCamera() -> n
    void getTargetCamera(com.badlogic.gdx.math.Vector2) -> o
    float getTime_Tackt() -> p
    com.mygdx.tanks2d.Units.Tanks.TowerRotation getTr() -> q
    boolean isLive() -> r
    void moveMainTank(com.badlogic.gdx.math.Vector2,boolean) -> s
    boolean redyToAttack() -> t
    void renderTank(com.badlogic.gdx.math.Vector2,boolean) -> u
    void replace_textures() -> v
    void respownTank() -> w
    void rotation_the_tower(com.badlogic.gdx.math.Vector2) -> x
    void send_my_coordinat() -> y
    void setHp(int) -> z
com.mygdx.tanks2d.Units.Tanks.TanksOther -> k1.c:
    com.badlogic.gdx.math.Vector2 tRotation -> o
    com.badlogic.gdx.math.Vector2 temp -> n
    java.util.HashMap listOpponents -> b
    java.util.HashMap deltaSledVec -> d
    java.util.HashMap listSled -> c
    com.badlogic.gdx.graphics.Texture img_1 -> g
    com.badlogic.gdx.graphics.Texture img -> f
    com.badlogic.gdx.graphics.Texture imgB2 -> k
    com.badlogic.gdx.graphics.Texture img2 -> j
    com.badlogic.gdx.graphics.Texture img_1B -> i
    com.badlogic.gdx.graphics.Texture imgB -> h
    com.badlogic.gdx.graphics.Texture tower -> m
    com.badlogic.gdx.graphics.Texture b -> l
    com.badlogic.gdx.graphics.g2d.BitmapFont textFont -> a
    com.mygdx.tanks2d.Screens.GamePlayScreen gsp -> e
    void addSled(com.mygdx.tanks2d.Units.Tanks.OpponentsTanks) -> a
    void count_living() -> b
    int createOponent(float,float,int,float) -> c
    void delPlayer(int) -> d
    boolean getExists(int) -> e
    com.mygdx.tanks2d.Units.Tanks.OpponentsTanks getRandomPlayer() -> f
    com.mygdx.tanks2d.Units.Tanks.OpponentsTanks getTankForID(int) -> g
    com.badlogic.gdx.math.Vector2 isCollisionsTanks(com.badlogic.gdx.math.Vector2) -> h
    void print_nickname(com.badlogic.gdx.graphics.g2d.SpriteBatch,com.mygdx.tanks2d.Units.Tanks.OpponentsTanks) -> i
    void randerOtherTanks(com.badlogic.gdx.graphics.g2d.SpriteBatch) -> j
    void send_all_layer_live_100_hp() -> k
    void setTankPosition(com.mygdx.tanks2d.ClientNetWork.Network$PleyerPositionNom,java.lang.Boolean) -> l
    void updateColor(com.mygdx.tanks2d.Units.Tanks.OpponentsTanks,float) -> m
com.mygdx.tanks2d.Units.Tanks.TowerRotation -> k1.d:
    java.lang.Integer nomTarget -> f
    int myCommand -> j
    boolean rotation -> k
    boolean guidance -> l
    java.util.HashMap targetTreet -> b
    float timerTackt -> d
    com.badlogic.gdx.math.Vector2 myPosition -> i
    int target_tank -> e
    com.badlogic.gdx.math.Vector2 direction -> g
    com.badlogic.gdx.math.Vector2 direction_tower -> h
    java.util.HashMap listOpponents -> c
    boolean pip_song -> a
    float rast_to_target -> m
    boolean changeCommand() -> a
    void changeTarget() -> b
    void changeTarget(int) -> c
    boolean checkLen() -> d
    int getAnTower() -> e
    java.lang.Integer getNomTarget() -> f
    int getTargetSize() -> g
    float getTimerTackt() -> h
    boolean isGuidance() -> i
    boolean isRedyToAttac() -> j
    boolean isRotation() -> k
    void makingDecisionTower(float) -> l
    float returnAngle(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> m
    java.lang.Integer selectTarget() -> n
    void setRotation(boolean) -> o
    void targetDetectionTower(com.badlogic.gdx.math.Vector2) -> p
    void turningTower(float,float) -> q
    void update(float) -> r
com.mygdx.tanks2d.Utils.VectorUtils -> l1.a:
    com.badlogic.gdx.math.Vector2 tempVector2 -> a
    com.badlogic.gdx.math.Vector2 tempVector1 -> b
    com.badlogic.gdx.math.Vector3 tempVector3 -> c
    float getLen2(com.badlogic.gdx.math.Vector2,float,float) -> a
    float getLen2(com.badlogic.gdx.math.Vector2,com.badlogic.gdx.math.Vector2) -> b
org.objenesis.instantiator.ObjectInstantiator -> m1.a:
    java.lang.Object newInstance() -> a
org.objenesis.strategy.InstantiatorStrategy -> n1.a:
    org.objenesis.instantiator.ObjectInstantiator newInstantiatorOf(java.lang.Class) -> a
